// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: automations.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelAutomationPendingActionsByRuleID = `-- name: CancelAutomationPendingActionsByRuleID :exec
UPDATE automation_pending_actions
SET status = 'cancelled'
WHERE rule_id = $1 AND status = 'pending'
`

func (q *Queries) CancelAutomationPendingActionsByRuleID(ctx context.Context, ruleID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, cancelAutomationPendingActionsByRuleID, ruleID)
	return err
}

const countAutomationPendingActions = `-- name: CountAutomationPendingActions :one
SELECT COUNT(*)
FROM automation_pending_actions
WHERE user_id = $1
  AND ($2::uuid IS NULL OR rule_id = $2)
  AND ($3::varchar IS NULL OR status = $3)
  AND ($4::timestamptz IS NULL OR scheduled_for <= $4)
`

type CountAutomationPendingActionsParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
}

func (q *Queries) CountAutomationPendingActions(ctx context.Context, arg CountAutomationPendingActionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAutomationPendingActions,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAutomationRuleExecutions = `-- name: CountAutomationRuleExecutions :one
SELECT COUNT(*)
FROM automation_rule_executions
WHERE user_id = $1
  AND ($2::uuid IS NULL OR rule_id = $2)
  AND ($3::varchar IS NULL OR status = $3)
  AND ($4::timestamptz IS NULL OR started_at >= $4)
  AND ($5::timestamptz IS NULL OR started_at <= $5)
`

type CountAutomationRuleExecutionsParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
}

func (q *Queries) CountAutomationRuleExecutions(ctx context.Context, arg CountAutomationRuleExecutionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAutomationRuleExecutions,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAutomationRuleExecutionsSince = `-- name: CountAutomationRuleExecutionsSince :one
SELECT COUNT(*)
FROM automation_rule_executions
WHERE rule_id = $1 AND started_at >= $2
`

type CountAutomationRuleExecutionsSinceParams struct {
	RuleID    pgtype.UUID        `json:"rule_id"`
	StartedAt pgtype.Timestamptz `json:"started_at"`
}

func (q *Queries) CountAutomationRuleExecutionsSince(ctx context.Context, arg CountAutomationRuleExecutionsSinceParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAutomationRuleExecutionsSince, arg.RuleID, arg.StartedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAutomationRules = `-- name: CountAutomationRules :one
SELECT COUNT(*)
FROM automation_rules
WHERE user_id = $1
  AND ($2::boolean IS NULL OR enabled = $2)
  AND ($3::varchar IS NULL OR trigger_type = $3)
  AND ($4::text[] IS NULL OR tags && $4)
`

type CountAutomationRulesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 bool        `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 []string    `json:"column_4"`
}

func (q *Queries) CountAutomationRules(ctx context.Context, arg CountAutomationRulesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAutomationRules,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAutomationRulesByUserID = `-- name: CountAutomationRulesByUserID :one
SELECT COUNT(*) FROM automation_rules WHERE user_id = $1
`

func (q *Queries) CountAutomationRulesByUserID(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countAutomationRulesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAutomationPendingAction = `-- name: CreateAutomationPendingAction :exec
INSERT INTO automation_pending_actions (
    id, execution_id, rule_id, user_id, action_type, action_params,
    scheduled_for, status, executed_at, result, error_message,
    retry_count, max_retries, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
`

type CreateAutomationPendingActionParams struct {
	ID           pgtype.UUID        `json:"id"`
	ExecutionID  pgtype.UUID        `json:"execution_id"`
	RuleID       pgtype.UUID        `json:"rule_id"`
	UserID       pgtype.UUID        `json:"user_id"`
	ActionType   string             `json:"action_type"`
	ActionParams []byte             `json:"action_params"`
	ScheduledFor pgtype.Timestamptz `json:"scheduled_for"`
	Status       string             `json:"status"`
	ExecutedAt   pgtype.Timestamptz `json:"executed_at"`
	Result       []byte             `json:"result"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	RetryCount   int32              `json:"retry_count"`
	MaxRetries   int32              `json:"max_retries"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateAutomationPendingAction(ctx context.Context, arg CreateAutomationPendingActionParams) error {
	_, err := q.db.Exec(ctx, createAutomationPendingAction,
		arg.ID,
		arg.ExecutionID,
		arg.RuleID,
		arg.UserID,
		arg.ActionType,
		arg.ActionParams,
		arg.ScheduledFor,
		arg.Status,
		arg.ExecutedAt,
		arg.Result,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.MaxRetries,
		arg.CreatedAt,
	)
	return err
}

const createAutomationRule = `-- name: CreateAutomationRule :exec
INSERT INTO automation_rules (
    id, user_id, name, description, enabled, priority,
    trigger_type, trigger_config, conditions, condition_operator,
    actions, cooldown_seconds, max_executions_per_hour, tags,
    created_at, updated_at, last_triggered_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
)
`

type CreateAutomationRuleParams struct {
	ID                   pgtype.UUID        `json:"id"`
	UserID               pgtype.UUID        `json:"user_id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Enabled              bool               `json:"enabled"`
	Priority             int32              `json:"priority"`
	TriggerType          string             `json:"trigger_type"`
	TriggerConfig        []byte             `json:"trigger_config"`
	Conditions           []byte             `json:"conditions"`
	ConditionOperator    string             `json:"condition_operator"`
	Actions              []byte             `json:"actions"`
	CooldownSeconds      int32              `json:"cooldown_seconds"`
	MaxExecutionsPerHour pgtype.Int4        `json:"max_executions_per_hour"`
	Tags                 []string           `json:"tags"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	LastTriggeredAt      pgtype.Timestamptz `json:"last_triggered_at"`
}

func (q *Queries) CreateAutomationRule(ctx context.Context, arg CreateAutomationRuleParams) error {
	_, err := q.db.Exec(ctx, createAutomationRule,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.Priority,
		arg.TriggerType,
		arg.TriggerConfig,
		arg.Conditions,
		arg.ConditionOperator,
		arg.Actions,
		arg.CooldownSeconds,
		arg.MaxExecutionsPerHour,
		arg.Tags,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastTriggeredAt,
	)
	return err
}

const createAutomationRuleExecution = `-- name: CreateAutomationRuleExecution :exec
INSERT INTO automation_rule_executions (
    id, rule_id, user_id, trigger_event_type, trigger_event_payload,
    status, actions_executed, error_message, error_details,
    started_at, completed_at, duration_ms, skip_reason
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
`

type CreateAutomationRuleExecutionParams struct {
	ID                  pgtype.UUID        `json:"id"`
	RuleID              pgtype.UUID        `json:"rule_id"`
	UserID              pgtype.UUID        `json:"user_id"`
	TriggerEventType    pgtype.Text        `json:"trigger_event_type"`
	TriggerEventPayload []byte             `json:"trigger_event_payload"`
	Status              string             `json:"status"`
	ActionsExecuted     []byte             `json:"actions_executed"`
	ErrorMessage        pgtype.Text        `json:"error_message"`
	ErrorDetails        []byte             `json:"error_details"`
	StartedAt           pgtype.Timestamptz `json:"started_at"`
	CompletedAt         pgtype.Timestamptz `json:"completed_at"`
	DurationMs          pgtype.Int4        `json:"duration_ms"`
	SkipReason          pgtype.Text        `json:"skip_reason"`
}

func (q *Queries) CreateAutomationRuleExecution(ctx context.Context, arg CreateAutomationRuleExecutionParams) error {
	_, err := q.db.Exec(ctx, createAutomationRuleExecution,
		arg.ID,
		arg.RuleID,
		arg.UserID,
		arg.TriggerEventType,
		arg.TriggerEventPayload,
		arg.Status,
		arg.ActionsExecuted,
		arg.ErrorMessage,
		arg.ErrorDetails,
		arg.StartedAt,
		arg.CompletedAt,
		arg.DurationMs,
		arg.SkipReason,
	)
	return err
}

const deleteAutomationRule = `-- name: DeleteAutomationRule :exec
DELETE FROM automation_rules WHERE id = $1
`

func (q *Queries) DeleteAutomationRule(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAutomationRule, id)
	return err
}

const deleteAutomationRuleExecutionsOlderThan = `-- name: DeleteAutomationRuleExecutionsOlderThan :execrows
DELETE FROM automation_rule_executions
WHERE completed_at < $1
`

func (q *Queries) DeleteAutomationRuleExecutionsOlderThan(ctx context.Context, completedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteAutomationRuleExecutionsOlderThan, completedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteExecutedAutomationPendingActions = `-- name: DeleteExecutedAutomationPendingActions :execrows
DELETE FROM automation_pending_actions
WHERE status IN ('executed', 'cancelled', 'failed')
  AND executed_at < $1
`

func (q *Queries) DeleteExecutedAutomationPendingActions(ctx context.Context, executedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExecutedAutomationPendingActions, executedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAutomationPendingActionByID = `-- name: GetAutomationPendingActionByID :one

SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE id = $1
`

// Automation Pending Actions
func (q *Queries) GetAutomationPendingActionByID(ctx context.Context, id pgtype.UUID) (AutomationPendingAction, error) {
	row := q.db.QueryRow(ctx, getAutomationPendingActionByID, id)
	var i AutomationPendingAction
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.RuleID,
		&i.UserID,
		&i.ActionType,
		&i.ActionParams,
		&i.ScheduledFor,
		&i.Status,
		&i.ExecutedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.CreatedAt,
	)
	return i, err
}

const getAutomationPendingActionsByExecutionID = `-- name: GetAutomationPendingActionsByExecutionID :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE execution_id = $1
ORDER BY scheduled_for ASC
`

func (q *Queries) GetAutomationPendingActionsByExecutionID(ctx context.Context, executionID pgtype.UUID) ([]AutomationPendingAction, error) {
	rows, err := q.db.Query(ctx, getAutomationPendingActionsByExecutionID, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationPendingActionsByRuleID = `-- name: GetAutomationPendingActionsByRuleID :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE rule_id = $1
ORDER BY scheduled_for DESC
`

func (q *Queries) GetAutomationPendingActionsByRuleID(ctx context.Context, ruleID pgtype.UUID) ([]AutomationPendingAction, error) {
	rows, err := q.db.Query(ctx, getAutomationPendingActionsByRuleID, ruleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationRuleByID = `-- name: GetAutomationRuleByID :one

SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE id = $1
`

// Automation Rules
func (q *Queries) GetAutomationRuleByID(ctx context.Context, id pgtype.UUID) (AutomationRule, error) {
	row := q.db.QueryRow(ctx, getAutomationRuleByID, id)
	var i AutomationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.Priority,
		&i.TriggerType,
		&i.TriggerConfig,
		&i.Conditions,
		&i.ConditionOperator,
		&i.Actions,
		&i.CooldownSeconds,
		&i.MaxExecutionsPerHour,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastTriggeredAt,
	)
	return i, err
}

const getAutomationRuleExecutionByID = `-- name: GetAutomationRuleExecutionByID :one

SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE id = $1
`

// Automation Rule Executions
func (q *Queries) GetAutomationRuleExecutionByID(ctx context.Context, id pgtype.UUID) (AutomationRuleExecution, error) {
	row := q.db.QueryRow(ctx, getAutomationRuleExecutionByID, id)
	var i AutomationRuleExecution
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.UserID,
		&i.TriggerEventType,
		&i.TriggerEventPayload,
		&i.Status,
		&i.ActionsExecuted,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.SkipReason,
	)
	return i, err
}

const getAutomationRuleExecutionsByRuleID = `-- name: GetAutomationRuleExecutionsByRuleID :many
SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE rule_id = $1
ORDER BY started_at DESC
LIMIT $2
`

type GetAutomationRuleExecutionsByRuleIDParams struct {
	RuleID pgtype.UUID `json:"rule_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetAutomationRuleExecutionsByRuleID(ctx context.Context, arg GetAutomationRuleExecutionsByRuleIDParams) ([]AutomationRuleExecution, error) {
	rows, err := q.db.Query(ctx, getAutomationRuleExecutionsByRuleID, arg.RuleID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRuleExecution{}
	for rows.Next() {
		var i AutomationRuleExecution
		if err := rows.Scan(
			&i.ID,
			&i.RuleID,
			&i.UserID,
			&i.TriggerEventType,
			&i.TriggerEventPayload,
			&i.Status,
			&i.ActionsExecuted,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.SkipReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationRulesByUserID = `-- name: GetAutomationRulesByUserID :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = $1
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) GetAutomationRulesByUserID(ctx context.Context, userID pgtype.UUID) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, getAutomationRulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDueAutomationPendingActions = `-- name: GetDueAutomationPendingActions :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE status = 'pending' AND scheduled_for <= NOW()
ORDER BY scheduled_for ASC
LIMIT $1
`

func (q *Queries) GetDueAutomationPendingActions(ctx context.Context, limit int32) ([]AutomationPendingAction, error) {
	rows, err := q.db.Query(ctx, getDueAutomationPendingActions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledAutomationRulesByTriggerType = `-- name: GetEnabledAutomationRulesByTriggerType :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = $1 AND enabled = TRUE AND trigger_type = $2
ORDER BY priority DESC, created_at DESC
`

type GetEnabledAutomationRulesByTriggerTypeParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	TriggerType string      `json:"trigger_type"`
}

func (q *Queries) GetEnabledAutomationRulesByTriggerType(ctx context.Context, arg GetEnabledAutomationRulesByTriggerTypeParams) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, getEnabledAutomationRulesByTriggerType, arg.UserID, arg.TriggerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledAutomationRulesByUserID = `-- name: GetEnabledAutomationRulesByUserID :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = $1 AND enabled = TRUE
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) GetEnabledAutomationRulesByUserID(ctx context.Context, userID pgtype.UUID) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, getEnabledAutomationRulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAutomationRuleExecution = `-- name: GetLatestAutomationRuleExecution :one
SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE rule_id = $1
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetLatestAutomationRuleExecution(ctx context.Context, ruleID pgtype.UUID) (AutomationRuleExecution, error) {
	row := q.db.QueryRow(ctx, getLatestAutomationRuleExecution, ruleID)
	var i AutomationRuleExecution
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.UserID,
		&i.TriggerEventType,
		&i.TriggerEventPayload,
		&i.Status,
		&i.ActionsExecuted,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.SkipReason,
	)
	return i, err
}

const listAutomationPendingActions = `-- name: ListAutomationPendingActions :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE user_id = $1
  AND ($2::uuid IS NULL OR rule_id = $2)
  AND ($3::varchar IS NULL OR status = $3)
  AND ($4::timestamptz IS NULL OR scheduled_for <= $4)
ORDER BY scheduled_for DESC
LIMIT $5 OFFSET $6
`

type ListAutomationPendingActionsParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

func (q *Queries) ListAutomationPendingActions(ctx context.Context, arg ListAutomationPendingActionsParams) ([]AutomationPendingAction, error) {
	rows, err := q.db.Query(ctx, listAutomationPendingActions,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAutomationRuleExecutions = `-- name: ListAutomationRuleExecutions :many
SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE user_id = $1
  AND ($2::uuid IS NULL OR rule_id = $2)
  AND ($3::varchar IS NULL OR status = $3)
  AND ($4::timestamptz IS NULL OR started_at >= $4)
  AND ($5::timestamptz IS NULL OR started_at <= $5)
ORDER BY started_at DESC
LIMIT $6 OFFSET $7
`

type ListAutomationRuleExecutionsParams struct {
	UserID  pgtype.UUID        `json:"user_id"`
	Column2 pgtype.UUID        `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 pgtype.Timestamptz `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

func (q *Queries) ListAutomationRuleExecutions(ctx context.Context, arg ListAutomationRuleExecutionsParams) ([]AutomationRuleExecution, error) {
	rows, err := q.db.Query(ctx, listAutomationRuleExecutions,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRuleExecution{}
	for rows.Next() {
		var i AutomationRuleExecution
		if err := rows.Scan(
			&i.ID,
			&i.RuleID,
			&i.UserID,
			&i.TriggerEventType,
			&i.TriggerEventPayload,
			&i.Status,
			&i.ActionsExecuted,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.SkipReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAutomationRules = `-- name: ListAutomationRules :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = $1
  AND ($2::boolean IS NULL OR enabled = $2)
  AND ($3::varchar IS NULL OR trigger_type = $3)
  AND ($4::text[] IS NULL OR tags && $4)
ORDER BY priority DESC, created_at DESC
LIMIT $5 OFFSET $6
`

type ListAutomationRulesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 bool        `json:"column_2"`
	Column3 string      `json:"column_3"`
	Column4 []string    `json:"column_4"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) ListAutomationRules(ctx context.Context, arg ListAutomationRulesParams) ([]AutomationRule, error) {
	rows, err := q.db.Query(ctx, listAutomationRules,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAutomationPendingAction = `-- name: UpdateAutomationPendingAction :exec
UPDATE automation_pending_actions
SET status = $2,
    executed_at = $3,
    result = $4,
    error_message = $5,
    retry_count = $6
WHERE id = $1
`

type UpdateAutomationPendingActionParams struct {
	ID           pgtype.UUID        `json:"id"`
	Status       string             `json:"status"`
	ExecutedAt   pgtype.Timestamptz `json:"executed_at"`
	Result       []byte             `json:"result"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	RetryCount   int32              `json:"retry_count"`
}

func (q *Queries) UpdateAutomationPendingAction(ctx context.Context, arg UpdateAutomationPendingActionParams) error {
	_, err := q.db.Exec(ctx, updateAutomationPendingAction,
		arg.ID,
		arg.Status,
		arg.ExecutedAt,
		arg.Result,
		arg.ErrorMessage,
		arg.RetryCount,
	)
	return err
}

const updateAutomationRule = `-- name: UpdateAutomationRule :exec
UPDATE automation_rules
SET name = $2,
    description = $3,
    enabled = $4,
    priority = $5,
    trigger_type = $6,
    trigger_config = $7,
    conditions = $8,
    condition_operator = $9,
    actions = $10,
    cooldown_seconds = $11,
    max_executions_per_hour = $12,
    tags = $13,
    updated_at = $14,
    last_triggered_at = $15
WHERE id = $1
`

type UpdateAutomationRuleParams struct {
	ID                   pgtype.UUID        `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Enabled              bool               `json:"enabled"`
	Priority             int32              `json:"priority"`
	TriggerType          string             `json:"trigger_type"`
	TriggerConfig        []byte             `json:"trigger_config"`
	Conditions           []byte             `json:"conditions"`
	ConditionOperator    string             `json:"condition_operator"`
	Actions              []byte             `json:"actions"`
	CooldownSeconds      int32              `json:"cooldown_seconds"`
	MaxExecutionsPerHour pgtype.Int4        `json:"max_executions_per_hour"`
	Tags                 []string           `json:"tags"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	LastTriggeredAt      pgtype.Timestamptz `json:"last_triggered_at"`
}

func (q *Queries) UpdateAutomationRule(ctx context.Context, arg UpdateAutomationRuleParams) error {
	_, err := q.db.Exec(ctx, updateAutomationRule,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.Priority,
		arg.TriggerType,
		arg.TriggerConfig,
		arg.Conditions,
		arg.ConditionOperator,
		arg.Actions,
		arg.CooldownSeconds,
		arg.MaxExecutionsPerHour,
		arg.Tags,
		arg.UpdatedAt,
		arg.LastTriggeredAt,
	)
	return err
}

const updateAutomationRuleExecution = `-- name: UpdateAutomationRuleExecution :exec
UPDATE automation_rule_executions
SET status = $2,
    actions_executed = $3,
    error_message = $4,
    error_details = $5,
    completed_at = $6,
    duration_ms = $7,
    skip_reason = $8
WHERE id = $1
`

type UpdateAutomationRuleExecutionParams struct {
	ID              pgtype.UUID        `json:"id"`
	Status          string             `json:"status"`
	ActionsExecuted []byte             `json:"actions_executed"`
	ErrorMessage    pgtype.Text        `json:"error_message"`
	ErrorDetails    []byte             `json:"error_details"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	DurationMs      pgtype.Int4        `json:"duration_ms"`
	SkipReason      pgtype.Text        `json:"skip_reason"`
}

func (q *Queries) UpdateAutomationRuleExecution(ctx context.Context, arg UpdateAutomationRuleExecutionParams) error {
	_, err := q.db.Exec(ctx, updateAutomationRuleExecution,
		arg.ID,
		arg.Status,
		arg.ActionsExecuted,
		arg.ErrorMessage,
		arg.ErrorDetails,
		arg.CompletedAt,
		arg.DurationMs,
		arg.SkipReason,
	)
	return err
}
