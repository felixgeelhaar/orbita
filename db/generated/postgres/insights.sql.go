// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: insights.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProductivityGoal = `-- name: CreateProductivityGoal :exec
INSERT INTO productivity_goals (
    id, user_id, goal_type, target_value, current_value,
    period_type, period_start, period_end, achieved, achieved_at
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8, $9, $10
)
`

type CreateProductivityGoalParams struct {
	ID           pgtype.UUID        `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	GoalType     string             `json:"goal_type"`
	TargetValue  int32              `json:"target_value"`
	CurrentValue int32              `json:"current_value"`
	PeriodType   string             `json:"period_type"`
	PeriodStart  pgtype.Date        `json:"period_start"`
	PeriodEnd    pgtype.Date        `json:"period_end"`
	Achieved     bool               `json:"achieved"`
	AchievedAt   pgtype.Timestamptz `json:"achieved_at"`
}

// Productivity Goals
func (q *Queries) CreateProductivityGoal(ctx context.Context, arg CreateProductivityGoalParams) error {
	_, err := q.db.Exec(ctx, createProductivityGoal,
		arg.ID,
		arg.UserID,
		arg.GoalType,
		arg.TargetValue,
		arg.CurrentValue,
		arg.PeriodType,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Achieved,
		arg.AchievedAt,
	)
	return err
}

const createProductivitySnapshot = `-- name: CreateProductivitySnapshot :exec
INSERT INTO productivity_snapshots (
    id, user_id, snapshot_date,
    tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes,
    blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate,
    habits_due, habits_completed, habit_completion_rate, longest_streak,
    focus_sessions, total_focus_minutes, avg_focus_session_minutes,
    productivity_score, peak_hours, time_by_category, computed_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18,
    $19, $20, $21,
    $22, $23, $24, $25
)
`

type CreateProductivitySnapshotParams struct {
	ID                     pgtype.UUID        `json:"id"`
	UserID                 pgtype.UUID        `json:"user_id"`
	SnapshotDate           pgtype.Date        `json:"snapshot_date"`
	TasksCreated           int32              `json:"tasks_created"`
	TasksCompleted         int32              `json:"tasks_completed"`
	TasksOverdue           int32              `json:"tasks_overdue"`
	TaskCompletionRate     pgtype.Numeric     `json:"task_completion_rate"`
	AvgTaskDurationMinutes pgtype.Int4        `json:"avg_task_duration_minutes"`
	BlocksScheduled        int32              `json:"blocks_scheduled"`
	BlocksCompleted        int32              `json:"blocks_completed"`
	BlocksMissed           int32              `json:"blocks_missed"`
	ScheduledMinutes       int32              `json:"scheduled_minutes"`
	CompletedMinutes       int32              `json:"completed_minutes"`
	BlockCompletionRate    pgtype.Numeric     `json:"block_completion_rate"`
	HabitsDue              int32              `json:"habits_due"`
	HabitsCompleted        int32              `json:"habits_completed"`
	HabitCompletionRate    pgtype.Numeric     `json:"habit_completion_rate"`
	LongestStreak          int32              `json:"longest_streak"`
	FocusSessions          int32              `json:"focus_sessions"`
	TotalFocusMinutes      int32              `json:"total_focus_minutes"`
	AvgFocusSessionMinutes pgtype.Int4        `json:"avg_focus_session_minutes"`
	ProductivityScore      int32              `json:"productivity_score"`
	PeakHours              []byte             `json:"peak_hours"`
	TimeByCategory         []byte             `json:"time_by_category"`
	ComputedAt             pgtype.Timestamptz `json:"computed_at"`
}

func (q *Queries) CreateProductivitySnapshot(ctx context.Context, arg CreateProductivitySnapshotParams) error {
	_, err := q.db.Exec(ctx, createProductivitySnapshot,
		arg.ID,
		arg.UserID,
		arg.SnapshotDate,
		arg.TasksCreated,
		arg.TasksCompleted,
		arg.TasksOverdue,
		arg.TaskCompletionRate,
		arg.AvgTaskDurationMinutes,
		arg.BlocksScheduled,
		arg.BlocksCompleted,
		arg.BlocksMissed,
		arg.ScheduledMinutes,
		arg.CompletedMinutes,
		arg.BlockCompletionRate,
		arg.HabitsDue,
		arg.HabitsCompleted,
		arg.HabitCompletionRate,
		arg.LongestStreak,
		arg.FocusSessions,
		arg.TotalFocusMinutes,
		arg.AvgFocusSessionMinutes,
		arg.ProductivityScore,
		arg.PeakHours,
		arg.TimeByCategory,
		arg.ComputedAt,
	)
	return err
}

const createTimeSession = `-- name: CreateTimeSession :exec
INSERT INTO time_sessions (
    id, user_id, session_type, reference_id, title, category,
    started_at, ended_at, duration_minutes, status, interruptions, notes
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11, $12
)
`

type CreateTimeSessionParams struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	SessionType     string             `json:"session_type"`
	ReferenceID     pgtype.UUID        `json:"reference_id"`
	Title           string             `json:"title"`
	Category        pgtype.Text        `json:"category"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	EndedAt         pgtype.Timestamptz `json:"ended_at"`
	DurationMinutes pgtype.Int4        `json:"duration_minutes"`
	Status          string             `json:"status"`
	Interruptions   int32              `json:"interruptions"`
	Notes           pgtype.Text        `json:"notes"`
}

// Time Sessions
func (q *Queries) CreateTimeSession(ctx context.Context, arg CreateTimeSessionParams) error {
	_, err := q.db.Exec(ctx, createTimeSession,
		arg.ID,
		arg.UserID,
		arg.SessionType,
		arg.ReferenceID,
		arg.Title,
		arg.Category,
		arg.StartedAt,
		arg.EndedAt,
		arg.DurationMinutes,
		arg.Status,
		arg.Interruptions,
		arg.Notes,
	)
	return err
}

const createWeeklySummary = `-- name: CreateWeeklySummary :exec
INSERT INTO weekly_summaries (
    id, user_id, week_start, week_end,
    total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes,
    avg_daily_productivity_score, avg_daily_focus_minutes,
    productivity_trend, focus_trend,
    most_productive_day, least_productive_day,
    habits_with_streak, longest_streak, computed_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, $10,
    $11, $12,
    $13, $14,
    $15, $16, $17
)
`

type CreateWeeklySummaryParams struct {
	ID                        pgtype.UUID        `json:"id"`
	UserID                    pgtype.UUID        `json:"user_id"`
	WeekStart                 pgtype.Date        `json:"week_start"`
	WeekEnd                   pgtype.Date        `json:"week_end"`
	TotalTasksCompleted       int32              `json:"total_tasks_completed"`
	TotalHabitsCompleted      int32              `json:"total_habits_completed"`
	TotalBlocksCompleted      int32              `json:"total_blocks_completed"`
	TotalFocusMinutes         int32              `json:"total_focus_minutes"`
	AvgDailyProductivityScore pgtype.Numeric     `json:"avg_daily_productivity_score"`
	AvgDailyFocusMinutes      pgtype.Int4        `json:"avg_daily_focus_minutes"`
	ProductivityTrend         pgtype.Numeric     `json:"productivity_trend"`
	FocusTrend                pgtype.Numeric     `json:"focus_trend"`
	MostProductiveDay         pgtype.Date        `json:"most_productive_day"`
	LeastProductiveDay        pgtype.Date        `json:"least_productive_day"`
	HabitsWithStreak          int32              `json:"habits_with_streak"`
	LongestStreak             int32              `json:"longest_streak"`
	ComputedAt                pgtype.Timestamptz `json:"computed_at"`
}

// Weekly Summaries
func (q *Queries) CreateWeeklySummary(ctx context.Context, arg CreateWeeklySummaryParams) error {
	_, err := q.db.Exec(ctx, createWeeklySummary,
		arg.ID,
		arg.UserID,
		arg.WeekStart,
		arg.WeekEnd,
		arg.TotalTasksCompleted,
		arg.TotalHabitsCompleted,
		arg.TotalBlocksCompleted,
		arg.TotalFocusMinutes,
		arg.AvgDailyProductivityScore,
		arg.AvgDailyFocusMinutes,
		arg.ProductivityTrend,
		arg.FocusTrend,
		arg.MostProductiveDay,
		arg.LeastProductiveDay,
		arg.HabitsWithStreak,
		arg.LongestStreak,
		arg.ComputedAt,
	)
	return err
}

const deleteProductivityGoal = `-- name: DeleteProductivityGoal :exec
DELETE FROM productivity_goals WHERE id = $1
`

func (q *Queries) DeleteProductivityGoal(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductivityGoal, id)
	return err
}

const deleteTimeSession = `-- name: DeleteTimeSession :exec
DELETE FROM time_sessions WHERE id = $1
`

func (q *Queries) DeleteTimeSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTimeSession, id)
	return err
}

const getAchievedProductivityGoals = `-- name: GetAchievedProductivityGoals :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = $1
  AND achieved = true
ORDER BY achieved_at DESC
LIMIT $2
`

type GetAchievedProductivityGoalsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetAchievedProductivityGoals(ctx context.Context, arg GetAchievedProductivityGoalsParams) ([]ProductivityGoal, error) {
	rows, err := q.db.Query(ctx, getAchievedProductivityGoals, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveProductivityGoals = `-- name: GetActiveProductivityGoals :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = $1
  AND period_end >= CURRENT_DATE
  AND NOT achieved
ORDER BY period_end ASC
`

func (q *Queries) GetActiveProductivityGoals(ctx context.Context, userID pgtype.UUID) ([]ProductivityGoal, error) {
	rows, err := q.db.Query(ctx, getActiveProductivityGoals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTimeSession = `-- name: GetActiveTimeSession :one
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = $1 AND status = 'active'
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveTimeSession(ctx context.Context, userID pgtype.UUID) (TimeSession, error) {
	row := q.db.QueryRow(ctx, getActiveTimeSession, userID)
	var i TimeSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ReferenceID,
		&i.Title,
		&i.Category,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationMinutes,
		&i.Status,
		&i.Interruptions,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAverageProductivityScore = `-- name: GetAverageProductivityScore :one
SELECT COALESCE(AVG(productivity_score), 0)::INTEGER as avg_score
FROM productivity_snapshots
WHERE user_id = $1
  AND snapshot_date >= $2
  AND snapshot_date <= $3
`

type GetAverageProductivityScoreParams struct {
	UserID         pgtype.UUID `json:"user_id"`
	SnapshotDate   pgtype.Date `json:"snapshot_date"`
	SnapshotDate_2 pgtype.Date `json:"snapshot_date_2"`
}

func (q *Queries) GetAverageProductivityScore(ctx context.Context, arg GetAverageProductivityScoreParams) (int32, error) {
	row := q.db.QueryRow(ctx, getAverageProductivityScore, arg.UserID, arg.SnapshotDate, arg.SnapshotDate_2)
	var avg_score int32
	err := row.Scan(&avg_score)
	return avg_score, err
}

const getHabitCompletionsByDateRange = `-- name: GetHabitCompletionsByDateRange :one
SELECT COUNT(*) as completions
FROM habit_completions hc
JOIN habits h ON h.id = hc.habit_id
WHERE h.user_id = $1
  AND hc.completed_at >= $2
  AND hc.completed_at < $3
`

type GetHabitCompletionsByDateRangeParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

func (q *Queries) GetHabitCompletionsByDateRange(ctx context.Context, arg GetHabitCompletionsByDateRangeParams) (int64, error) {
	row := q.db.QueryRow(ctx, getHabitCompletionsByDateRange, arg.UserID, arg.CompletedAt, arg.CompletedAt_2)
	var completions int64
	err := row.Scan(&completions)
	return completions, err
}

const getHabitsDueCount = `-- name: GetHabitsDueCount :one
SELECT COUNT(*) as due_count
FROM habits
WHERE user_id = $1
  AND archived = false
`

func (q *Queries) GetHabitsDueCount(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getHabitsDueCount, userID)
	var due_count int64
	err := row.Scan(&due_count)
	return due_count, err
}

const getLatestProductivitySnapshot = `-- name: GetLatestProductivitySnapshot :one
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = $1
ORDER BY snapshot_date DESC
LIMIT 1
`

func (q *Queries) GetLatestProductivitySnapshot(ctx context.Context, userID pgtype.UUID) (ProductivitySnapshot, error) {
	row := q.db.QueryRow(ctx, getLatestProductivitySnapshot, userID)
	var i ProductivitySnapshot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SnapshotDate,
		&i.TasksCreated,
		&i.TasksCompleted,
		&i.TasksOverdue,
		&i.TaskCompletionRate,
		&i.AvgTaskDurationMinutes,
		&i.BlocksScheduled,
		&i.BlocksCompleted,
		&i.BlocksMissed,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
		&i.BlockCompletionRate,
		&i.HabitsDue,
		&i.HabitsCompleted,
		&i.HabitCompletionRate,
		&i.LongestStreak,
		&i.FocusSessions,
		&i.TotalFocusMinutes,
		&i.AvgFocusSessionMinutes,
		&i.ProductivityScore,
		&i.PeakHours,
		&i.TimeByCategory,
		&i.ComputedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestWeeklySummary = `-- name: GetLatestWeeklySummary :one
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = $1
ORDER BY week_start DESC
LIMIT 1
`

func (q *Queries) GetLatestWeeklySummary(ctx context.Context, userID pgtype.UUID) (WeeklySummary, error) {
	row := q.db.QueryRow(ctx, getLatestWeeklySummary, userID)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.TotalTasksCompleted,
		&i.TotalHabitsCompleted,
		&i.TotalBlocksCompleted,
		&i.TotalFocusMinutes,
		&i.AvgDailyProductivityScore,
		&i.AvgDailyFocusMinutes,
		&i.ProductivityTrend,
		&i.FocusTrend,
		&i.MostProductiveDay,
		&i.LeastProductiveDay,
		&i.HabitsWithStreak,
		&i.LongestStreak,
		&i.ComputedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLongestActiveStreak = `-- name: GetLongestActiveStreak :one
SELECT COALESCE(MAX(streak), 0)::INTEGER as longest_streak
FROM habits
WHERE user_id = $1
  AND archived = false
`

func (q *Queries) GetLongestActiveStreak(ctx context.Context, userID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getLongestActiveStreak, userID)
	var longest_streak int32
	err := row.Scan(&longest_streak)
	return longest_streak, err
}

const getPeakProductivityHours = `-- name: GetPeakProductivityHours :many
SELECT
    EXTRACT(HOUR FROM completed_at)::INTEGER as hour,
    COUNT(*) as completions
FROM tasks
WHERE user_id = $1
  AND completed_at >= $2
  AND completed_at < $3
  AND completed_at IS NOT NULL
GROUP BY EXTRACT(HOUR FROM completed_at)
ORDER BY completions DESC
LIMIT 5
`

type GetPeakProductivityHoursParams struct {
	UserID        pgtype.UUID        `json:"user_id"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
	CompletedAt_2 pgtype.Timestamptz `json:"completed_at_2"`
}

type GetPeakProductivityHoursRow struct {
	Hour        int32 `json:"hour"`
	Completions int64 `json:"completions"`
}

func (q *Queries) GetPeakProductivityHours(ctx context.Context, arg GetPeakProductivityHoursParams) ([]GetPeakProductivityHoursRow, error) {
	rows, err := q.db.Query(ctx, getPeakProductivityHours, arg.UserID, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPeakProductivityHoursRow{}
	for rows.Next() {
		var i GetPeakProductivityHoursRow
		if err := rows.Scan(&i.Hour, &i.Completions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityGoal = `-- name: GetProductivityGoal :one
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals WHERE id = $1
`

func (q *Queries) GetProductivityGoal(ctx context.Context, id pgtype.UUID) (ProductivityGoal, error) {
	row := q.db.QueryRow(ctx, getProductivityGoal, id)
	var i ProductivityGoal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GoalType,
		&i.TargetValue,
		&i.CurrentValue,
		&i.PeriodType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Achieved,
		&i.AchievedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductivityGoalsByPeriod = `-- name: GetProductivityGoalsByPeriod :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = $1
  AND period_start >= $2
  AND period_end <= $3
ORDER BY period_start ASC
`

type GetProductivityGoalsByPeriodParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	PeriodStart pgtype.Date `json:"period_start"`
	PeriodEnd   pgtype.Date `json:"period_end"`
}

func (q *Queries) GetProductivityGoalsByPeriod(ctx context.Context, arg GetProductivityGoalsByPeriodParams) ([]ProductivityGoal, error) {
	rows, err := q.db.Query(ctx, getProductivityGoalsByPeriod, arg.UserID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityGoalsByType = `-- name: GetProductivityGoalsByType :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = $1 AND goal_type = $2
ORDER BY period_start DESC
`

type GetProductivityGoalsByTypeParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	GoalType string      `json:"goal_type"`
}

func (q *Queries) GetProductivityGoalsByType(ctx context.Context, arg GetProductivityGoalsByTypeParams) ([]ProductivityGoal, error) {
	rows, err := q.db.Query(ctx, getProductivityGoalsByType, arg.UserID, arg.GoalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivitySnapshot = `-- name: GetProductivitySnapshot :one
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = $1 AND snapshot_date = $2
`

type GetProductivitySnapshotParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	SnapshotDate pgtype.Date `json:"snapshot_date"`
}

func (q *Queries) GetProductivitySnapshot(ctx context.Context, arg GetProductivitySnapshotParams) (ProductivitySnapshot, error) {
	row := q.db.QueryRow(ctx, getProductivitySnapshot, arg.UserID, arg.SnapshotDate)
	var i ProductivitySnapshot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SnapshotDate,
		&i.TasksCreated,
		&i.TasksCompleted,
		&i.TasksOverdue,
		&i.TaskCompletionRate,
		&i.AvgTaskDurationMinutes,
		&i.BlocksScheduled,
		&i.BlocksCompleted,
		&i.BlocksMissed,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
		&i.BlockCompletionRate,
		&i.HabitsDue,
		&i.HabitsCompleted,
		&i.HabitCompletionRate,
		&i.LongestStreak,
		&i.FocusSessions,
		&i.TotalFocusMinutes,
		&i.AvgFocusSessionMinutes,
		&i.ProductivityScore,
		&i.PeakHours,
		&i.TimeByCategory,
		&i.ComputedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductivitySnapshotRange = `-- name: GetProductivitySnapshotRange :many
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = $1
  AND snapshot_date >= $2
  AND snapshot_date <= $3
ORDER BY snapshot_date DESC
`

type GetProductivitySnapshotRangeParams struct {
	UserID         pgtype.UUID `json:"user_id"`
	SnapshotDate   pgtype.Date `json:"snapshot_date"`
	SnapshotDate_2 pgtype.Date `json:"snapshot_date_2"`
}

func (q *Queries) GetProductivitySnapshotRange(ctx context.Context, arg GetProductivitySnapshotRangeParams) ([]ProductivitySnapshot, error) {
	rows, err := q.db.Query(ctx, getProductivitySnapshotRange, arg.UserID, arg.SnapshotDate, arg.SnapshotDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivitySnapshot{}
	for rows.Next() {
		var i ProductivitySnapshot
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SnapshotDate,
			&i.TasksCreated,
			&i.TasksCompleted,
			&i.TasksOverdue,
			&i.TaskCompletionRate,
			&i.AvgTaskDurationMinutes,
			&i.BlocksScheduled,
			&i.BlocksCompleted,
			&i.BlocksMissed,
			&i.ScheduledMinutes,
			&i.CompletedMinutes,
			&i.BlockCompletionRate,
			&i.HabitsDue,
			&i.HabitsCompleted,
			&i.HabitCompletionRate,
			&i.LongestStreak,
			&i.FocusSessions,
			&i.TotalFocusMinutes,
			&i.AvgFocusSessionMinutes,
			&i.ProductivityScore,
			&i.PeakHours,
			&i.TimeByCategory,
			&i.ComputedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivitySnapshots = `-- name: GetProductivitySnapshots :many
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = $1
ORDER BY snapshot_date DESC
LIMIT $2
`

type GetProductivitySnapshotsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetProductivitySnapshots(ctx context.Context, arg GetProductivitySnapshotsParams) ([]ProductivitySnapshot, error) {
	rows, err := q.db.Query(ctx, getProductivitySnapshots, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivitySnapshot{}
	for rows.Next() {
		var i ProductivitySnapshot
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SnapshotDate,
			&i.TasksCreated,
			&i.TasksCompleted,
			&i.TasksOverdue,
			&i.TaskCompletionRate,
			&i.AvgTaskDurationMinutes,
			&i.BlocksScheduled,
			&i.BlocksCompleted,
			&i.BlocksMissed,
			&i.ScheduledMinutes,
			&i.CompletedMinutes,
			&i.BlockCompletionRate,
			&i.HabitsDue,
			&i.HabitsCompleted,
			&i.HabitCompletionRate,
			&i.LongestStreak,
			&i.FocusSessions,
			&i.TotalFocusMinutes,
			&i.AvgFocusSessionMinutes,
			&i.ProductivityScore,
			&i.PeakHours,
			&i.TimeByCategory,
			&i.ComputedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskCompletionsByDateRange = `-- name: GetTaskCompletionsByDateRange :one
SELECT
    COUNT(*) FILTER (WHERE status = 'completed') as completed,
    COUNT(*) FILTER (WHERE status = 'pending' AND due_date < NOW()) as overdue,
    COUNT(*) as total
FROM tasks
WHERE user_id = $1
  AND created_at >= $2
  AND created_at < $3
`

type GetTaskCompletionsByDateRangeParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetTaskCompletionsByDateRangeRow struct {
	Completed int64 `json:"completed"`
	Overdue   int64 `json:"overdue"`
	Total     int64 `json:"total"`
}

// Analytics queries using existing tables
func (q *Queries) GetTaskCompletionsByDateRange(ctx context.Context, arg GetTaskCompletionsByDateRangeParams) (GetTaskCompletionsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getTaskCompletionsByDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetTaskCompletionsByDateRangeRow
	err := row.Scan(&i.Completed, &i.Overdue, &i.Total)
	return i, err
}

const getTimeBlockStatsByDateRange = `-- name: GetTimeBlockStatsByDateRange :one
SELECT
    COUNT(*) as total_blocks,
    COUNT(*) FILTER (WHERE completed = true) as completed_blocks,
    COUNT(*) FILTER (WHERE missed = true) as missed_blocks,
    COALESCE(SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60), 0)::INTEGER as scheduled_minutes,
    COALESCE(SUM(CASE WHEN completed THEN EXTRACT(EPOCH FROM (end_time - start_time)) / 60 ELSE 0 END), 0)::INTEGER as completed_minutes
FROM time_blocks
WHERE user_id = $1
  AND start_time >= $2
  AND start_time < $3
`

type GetTimeBlockStatsByDateRangeParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

type GetTimeBlockStatsByDateRangeRow struct {
	TotalBlocks      int64 `json:"total_blocks"`
	CompletedBlocks  int64 `json:"completed_blocks"`
	MissedBlocks     int64 `json:"missed_blocks"`
	ScheduledMinutes int32 `json:"scheduled_minutes"`
	CompletedMinutes int32 `json:"completed_minutes"`
}

func (q *Queries) GetTimeBlockStatsByDateRange(ctx context.Context, arg GetTimeBlockStatsByDateRangeParams) (GetTimeBlockStatsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getTimeBlockStatsByDateRange, arg.UserID, arg.StartTime, arg.StartTime_2)
	var i GetTimeBlockStatsByDateRangeRow
	err := row.Scan(
		&i.TotalBlocks,
		&i.CompletedBlocks,
		&i.MissedBlocks,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
	)
	return i, err
}

const getTimeByBlockType = `-- name: GetTimeByBlockType :many
SELECT
    block_type as category,
    COALESCE(SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60), 0)::INTEGER as minutes
FROM time_blocks
WHERE user_id = $1
  AND start_time >= $2
  AND start_time < $3
  AND completed = true
GROUP BY block_type
ORDER BY minutes DESC
`

type GetTimeByBlockTypeParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

type GetTimeByBlockTypeRow struct {
	Category string `json:"category"`
	Minutes  int32  `json:"minutes"`
}

func (q *Queries) GetTimeByBlockType(ctx context.Context, arg GetTimeByBlockTypeParams) ([]GetTimeByBlockTypeRow, error) {
	rows, err := q.db.Query(ctx, getTimeByBlockType, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimeByBlockTypeRow{}
	for rows.Next() {
		var i GetTimeByBlockTypeRow
		if err := rows.Scan(&i.Category, &i.Minutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSession = `-- name: GetTimeSession :one
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions WHERE id = $1
`

func (q *Queries) GetTimeSession(ctx context.Context, id pgtype.UUID) (TimeSession, error) {
	row := q.db.QueryRow(ctx, getTimeSession, id)
	var i TimeSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ReferenceID,
		&i.Title,
		&i.Category,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationMinutes,
		&i.Status,
		&i.Interruptions,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimeSessionsByDateRange = `-- name: GetTimeSessionsByDateRange :many
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = $1
  AND started_at >= $2
  AND started_at < $3
ORDER BY started_at DESC
`

type GetTimeSessionsByDateRangeParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	StartedAt_2 pgtype.Timestamptz `json:"started_at_2"`
}

func (q *Queries) GetTimeSessionsByDateRange(ctx context.Context, arg GetTimeSessionsByDateRangeParams) ([]TimeSession, error) {
	rows, err := q.db.Query(ctx, getTimeSessionsByDateRange, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeSession{}
	for rows.Next() {
		var i TimeSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ReferenceID,
			&i.Title,
			&i.Category,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationMinutes,
			&i.Status,
			&i.Interruptions,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSessionsByType = `-- name: GetTimeSessionsByType :many
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = $1 AND session_type = $2
ORDER BY started_at DESC
LIMIT $3
`

type GetTimeSessionsByTypeParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	SessionType string      `json:"session_type"`
	Limit       int32       `json:"limit"`
}

func (q *Queries) GetTimeSessionsByType(ctx context.Context, arg GetTimeSessionsByTypeParams) ([]TimeSession, error) {
	rows, err := q.db.Query(ctx, getTimeSessionsByType, arg.UserID, arg.SessionType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeSession{}
	for rows.Next() {
		var i TimeSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ReferenceID,
			&i.Title,
			&i.Category,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationMinutes,
			&i.Status,
			&i.Interruptions,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalFocusMinutesByDateRange = `-- name: GetTotalFocusMinutesByDateRange :one
SELECT COALESCE(SUM(duration_minutes), 0)::INTEGER as total_minutes
FROM time_sessions
WHERE user_id = $1
  AND session_type = 'focus'
  AND status = 'completed'
  AND started_at >= $2
  AND started_at < $3
`

type GetTotalFocusMinutesByDateRangeParams struct {
	UserID      pgtype.UUID        `json:"user_id"`
	StartedAt   pgtype.Timestamptz `json:"started_at"`
	StartedAt_2 pgtype.Timestamptz `json:"started_at_2"`
}

func (q *Queries) GetTotalFocusMinutesByDateRange(ctx context.Context, arg GetTotalFocusMinutesByDateRangeParams) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalFocusMinutesByDateRange, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	var total_minutes int32
	err := row.Scan(&total_minutes)
	return total_minutes, err
}

const getWeeklySummaries = `-- name: GetWeeklySummaries :many
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = $1
ORDER BY week_start DESC
LIMIT $2
`

type GetWeeklySummariesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetWeeklySummaries(ctx context.Context, arg GetWeeklySummariesParams) ([]WeeklySummary, error) {
	rows, err := q.db.Query(ctx, getWeeklySummaries, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WeeklySummary{}
	for rows.Next() {
		var i WeeklySummary
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WeekStart,
			&i.WeekEnd,
			&i.TotalTasksCompleted,
			&i.TotalHabitsCompleted,
			&i.TotalBlocksCompleted,
			&i.TotalFocusMinutes,
			&i.AvgDailyProductivityScore,
			&i.AvgDailyFocusMinutes,
			&i.ProductivityTrend,
			&i.FocusTrend,
			&i.MostProductiveDay,
			&i.LeastProductiveDay,
			&i.HabitsWithStreak,
			&i.LongestStreak,
			&i.ComputedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklySummary = `-- name: GetWeeklySummary :one
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = $1 AND week_start = $2
`

type GetWeeklySummaryParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	WeekStart pgtype.Date `json:"week_start"`
}

func (q *Queries) GetWeeklySummary(ctx context.Context, arg GetWeeklySummaryParams) (WeeklySummary, error) {
	row := q.db.QueryRow(ctx, getWeeklySummary, arg.UserID, arg.WeekStart)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.TotalTasksCompleted,
		&i.TotalHabitsCompleted,
		&i.TotalBlocksCompleted,
		&i.TotalFocusMinutes,
		&i.AvgDailyProductivityScore,
		&i.AvgDailyFocusMinutes,
		&i.ProductivityTrend,
		&i.FocusTrend,
		&i.MostProductiveDay,
		&i.LeastProductiveDay,
		&i.HabitsWithStreak,
		&i.LongestStreak,
		&i.ComputedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductivityGoal = `-- name: UpdateProductivityGoal :exec
UPDATE productivity_goals SET
    current_value = $2,
    achieved = $3,
    achieved_at = $4
WHERE id = $1
`

type UpdateProductivityGoalParams struct {
	ID           pgtype.UUID        `json:"id"`
	CurrentValue int32              `json:"current_value"`
	Achieved     bool               `json:"achieved"`
	AchievedAt   pgtype.Timestamptz `json:"achieved_at"`
}

func (q *Queries) UpdateProductivityGoal(ctx context.Context, arg UpdateProductivityGoalParams) error {
	_, err := q.db.Exec(ctx, updateProductivityGoal,
		arg.ID,
		arg.CurrentValue,
		arg.Achieved,
		arg.AchievedAt,
	)
	return err
}

const updateTimeSession = `-- name: UpdateTimeSession :exec
UPDATE time_sessions SET
    ended_at = $2,
    duration_minutes = $3,
    status = $4,
    interruptions = $5,
    notes = $6
WHERE id = $1
`

type UpdateTimeSessionParams struct {
	ID              pgtype.UUID        `json:"id"`
	EndedAt         pgtype.Timestamptz `json:"ended_at"`
	DurationMinutes pgtype.Int4        `json:"duration_minutes"`
	Status          string             `json:"status"`
	Interruptions   int32              `json:"interruptions"`
	Notes           pgtype.Text        `json:"notes"`
}

func (q *Queries) UpdateTimeSession(ctx context.Context, arg UpdateTimeSessionParams) error {
	_, err := q.db.Exec(ctx, updateTimeSession,
		arg.ID,
		arg.EndedAt,
		arg.DurationMinutes,
		arg.Status,
		arg.Interruptions,
		arg.Notes,
	)
	return err
}

const upsertProductivitySnapshot = `-- name: UpsertProductivitySnapshot :exec
INSERT INTO productivity_snapshots (
    id, user_id, snapshot_date,
    tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes,
    blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate,
    habits_due, habits_completed, habit_completion_rate, longest_streak,
    focus_sessions, total_focus_minutes, avg_focus_session_minutes,
    productivity_score, peak_hours, time_by_category, computed_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6, $7, $8,
    $9, $10, $11, $12, $13, $14,
    $15, $16, $17, $18,
    $19, $20, $21,
    $22, $23, $24, $25
)
ON CONFLICT (user_id, snapshot_date)
DO UPDATE SET
    tasks_created = EXCLUDED.tasks_created,
    tasks_completed = EXCLUDED.tasks_completed,
    tasks_overdue = EXCLUDED.tasks_overdue,
    task_completion_rate = EXCLUDED.task_completion_rate,
    avg_task_duration_minutes = EXCLUDED.avg_task_duration_minutes,
    blocks_scheduled = EXCLUDED.blocks_scheduled,
    blocks_completed = EXCLUDED.blocks_completed,
    blocks_missed = EXCLUDED.blocks_missed,
    scheduled_minutes = EXCLUDED.scheduled_minutes,
    completed_minutes = EXCLUDED.completed_minutes,
    block_completion_rate = EXCLUDED.block_completion_rate,
    habits_due = EXCLUDED.habits_due,
    habits_completed = EXCLUDED.habits_completed,
    habit_completion_rate = EXCLUDED.habit_completion_rate,
    longest_streak = EXCLUDED.longest_streak,
    focus_sessions = EXCLUDED.focus_sessions,
    total_focus_minutes = EXCLUDED.total_focus_minutes,
    avg_focus_session_minutes = EXCLUDED.avg_focus_session_minutes,
    productivity_score = EXCLUDED.productivity_score,
    peak_hours = EXCLUDED.peak_hours,
    time_by_category = EXCLUDED.time_by_category,
    computed_at = EXCLUDED.computed_at,
    updated_at = NOW()
`

type UpsertProductivitySnapshotParams struct {
	ID                     pgtype.UUID        `json:"id"`
	UserID                 pgtype.UUID        `json:"user_id"`
	SnapshotDate           pgtype.Date        `json:"snapshot_date"`
	TasksCreated           int32              `json:"tasks_created"`
	TasksCompleted         int32              `json:"tasks_completed"`
	TasksOverdue           int32              `json:"tasks_overdue"`
	TaskCompletionRate     pgtype.Numeric     `json:"task_completion_rate"`
	AvgTaskDurationMinutes pgtype.Int4        `json:"avg_task_duration_minutes"`
	BlocksScheduled        int32              `json:"blocks_scheduled"`
	BlocksCompleted        int32              `json:"blocks_completed"`
	BlocksMissed           int32              `json:"blocks_missed"`
	ScheduledMinutes       int32              `json:"scheduled_minutes"`
	CompletedMinutes       int32              `json:"completed_minutes"`
	BlockCompletionRate    pgtype.Numeric     `json:"block_completion_rate"`
	HabitsDue              int32              `json:"habits_due"`
	HabitsCompleted        int32              `json:"habits_completed"`
	HabitCompletionRate    pgtype.Numeric     `json:"habit_completion_rate"`
	LongestStreak          int32              `json:"longest_streak"`
	FocusSessions          int32              `json:"focus_sessions"`
	TotalFocusMinutes      int32              `json:"total_focus_minutes"`
	AvgFocusSessionMinutes pgtype.Int4        `json:"avg_focus_session_minutes"`
	ProductivityScore      int32              `json:"productivity_score"`
	PeakHours              []byte             `json:"peak_hours"`
	TimeByCategory         []byte             `json:"time_by_category"`
	ComputedAt             pgtype.Timestamptz `json:"computed_at"`
}

func (q *Queries) UpsertProductivitySnapshot(ctx context.Context, arg UpsertProductivitySnapshotParams) error {
	_, err := q.db.Exec(ctx, upsertProductivitySnapshot,
		arg.ID,
		arg.UserID,
		arg.SnapshotDate,
		arg.TasksCreated,
		arg.TasksCompleted,
		arg.TasksOverdue,
		arg.TaskCompletionRate,
		arg.AvgTaskDurationMinutes,
		arg.BlocksScheduled,
		arg.BlocksCompleted,
		arg.BlocksMissed,
		arg.ScheduledMinutes,
		arg.CompletedMinutes,
		arg.BlockCompletionRate,
		arg.HabitsDue,
		arg.HabitsCompleted,
		arg.HabitCompletionRate,
		arg.LongestStreak,
		arg.FocusSessions,
		arg.TotalFocusMinutes,
		arg.AvgFocusSessionMinutes,
		arg.ProductivityScore,
		arg.PeakHours,
		arg.TimeByCategory,
		arg.ComputedAt,
	)
	return err
}

const upsertWeeklySummary = `-- name: UpsertWeeklySummary :exec
INSERT INTO weekly_summaries (
    id, user_id, week_start, week_end,
    total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes,
    avg_daily_productivity_score, avg_daily_focus_minutes,
    productivity_trend, focus_trend,
    most_productive_day, least_productive_day,
    habits_with_streak, longest_streak, computed_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8,
    $9, $10,
    $11, $12,
    $13, $14,
    $15, $16, $17
)
ON CONFLICT (user_id, week_start)
DO UPDATE SET
    total_tasks_completed = EXCLUDED.total_tasks_completed,
    total_habits_completed = EXCLUDED.total_habits_completed,
    total_blocks_completed = EXCLUDED.total_blocks_completed,
    total_focus_minutes = EXCLUDED.total_focus_minutes,
    avg_daily_productivity_score = EXCLUDED.avg_daily_productivity_score,
    avg_daily_focus_minutes = EXCLUDED.avg_daily_focus_minutes,
    productivity_trend = EXCLUDED.productivity_trend,
    focus_trend = EXCLUDED.focus_trend,
    most_productive_day = EXCLUDED.most_productive_day,
    least_productive_day = EXCLUDED.least_productive_day,
    habits_with_streak = EXCLUDED.habits_with_streak,
    longest_streak = EXCLUDED.longest_streak,
    computed_at = EXCLUDED.computed_at
`

type UpsertWeeklySummaryParams struct {
	ID                        pgtype.UUID        `json:"id"`
	UserID                    pgtype.UUID        `json:"user_id"`
	WeekStart                 pgtype.Date        `json:"week_start"`
	WeekEnd                   pgtype.Date        `json:"week_end"`
	TotalTasksCompleted       int32              `json:"total_tasks_completed"`
	TotalHabitsCompleted      int32              `json:"total_habits_completed"`
	TotalBlocksCompleted      int32              `json:"total_blocks_completed"`
	TotalFocusMinutes         int32              `json:"total_focus_minutes"`
	AvgDailyProductivityScore pgtype.Numeric     `json:"avg_daily_productivity_score"`
	AvgDailyFocusMinutes      pgtype.Int4        `json:"avg_daily_focus_minutes"`
	ProductivityTrend         pgtype.Numeric     `json:"productivity_trend"`
	FocusTrend                pgtype.Numeric     `json:"focus_trend"`
	MostProductiveDay         pgtype.Date        `json:"most_productive_day"`
	LeastProductiveDay        pgtype.Date        `json:"least_productive_day"`
	HabitsWithStreak          int32              `json:"habits_with_streak"`
	LongestStreak             int32              `json:"longest_streak"`
	ComputedAt                pgtype.Timestamptz `json:"computed_at"`
}

func (q *Queries) UpsertWeeklySummary(ctx context.Context, arg UpsertWeeklySummaryParams) error {
	_, err := q.db.Exec(ctx, upsertWeeklySummary,
		arg.ID,
		arg.UserID,
		arg.WeekStart,
		arg.WeekEnd,
		arg.TotalTasksCompleted,
		arg.TotalHabitsCompleted,
		arg.TotalBlocksCompleted,
		arg.TotalFocusMinutes,
		arg.AvgDailyProductivityScore,
		arg.AvgDailyFocusMinutes,
		arg.ProductivityTrend,
		arg.FocusTrend,
		arg.MostProductiveDay,
		arg.LeastProductiveDay,
		arg.HabitsWithStreak,
		arg.LongestStreak,
		arg.ComputedAt,
	)
	return err
}
