// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: insights.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createProductivityGoal = `-- name: CreateProductivityGoal :exec

INSERT INTO productivity_goals (
    id, user_id, goal_type, target_value, current_value,
    period_type, period_start, period_end, achieved, achieved_at
) VALUES (
    ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?
)
`

type CreateProductivityGoalParams struct {
	ID           string         `json:"id"`
	UserID       string         `json:"user_id"`
	GoalType     string         `json:"goal_type"`
	TargetValue  int64          `json:"target_value"`
	CurrentValue int64          `json:"current_value"`
	PeriodType   string         `json:"period_type"`
	PeriodStart  string         `json:"period_start"`
	PeriodEnd    string         `json:"period_end"`
	Achieved     int64          `json:"achieved"`
	AchievedAt   sql.NullString `json:"achieved_at"`
}

// Productivity Goals
func (q *Queries) CreateProductivityGoal(ctx context.Context, arg CreateProductivityGoalParams) error {
	_, err := q.db.ExecContext(ctx, createProductivityGoal,
		arg.ID,
		arg.UserID,
		arg.GoalType,
		arg.TargetValue,
		arg.CurrentValue,
		arg.PeriodType,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Achieved,
		arg.AchievedAt,
	)
	return err
}

const createProductivitySnapshot = `-- name: CreateProductivitySnapshot :exec

INSERT INTO productivity_snapshots (
    id, user_id, snapshot_date,
    tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes,
    blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate,
    habits_due, habits_completed, habit_completion_rate, longest_streak,
    focus_sessions, total_focus_minutes, avg_focus_session_minutes,
    productivity_score, peak_hours, time_by_category, computed_at
) VALUES (
    ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?
)
`

type CreateProductivitySnapshotParams struct {
	ID                     string          `json:"id"`
	UserID                 string          `json:"user_id"`
	SnapshotDate           string          `json:"snapshot_date"`
	TasksCreated           int64           `json:"tasks_created"`
	TasksCompleted         int64           `json:"tasks_completed"`
	TasksOverdue           int64           `json:"tasks_overdue"`
	TaskCompletionRate     sql.NullFloat64 `json:"task_completion_rate"`
	AvgTaskDurationMinutes sql.NullInt64   `json:"avg_task_duration_minutes"`
	BlocksScheduled        int64           `json:"blocks_scheduled"`
	BlocksCompleted        int64           `json:"blocks_completed"`
	BlocksMissed           int64           `json:"blocks_missed"`
	ScheduledMinutes       int64           `json:"scheduled_minutes"`
	CompletedMinutes       int64           `json:"completed_minutes"`
	BlockCompletionRate    sql.NullFloat64 `json:"block_completion_rate"`
	HabitsDue              int64           `json:"habits_due"`
	HabitsCompleted        int64           `json:"habits_completed"`
	HabitCompletionRate    sql.NullFloat64 `json:"habit_completion_rate"`
	LongestStreak          int64           `json:"longest_streak"`
	FocusSessions          int64           `json:"focus_sessions"`
	TotalFocusMinutes      int64           `json:"total_focus_minutes"`
	AvgFocusSessionMinutes sql.NullInt64   `json:"avg_focus_session_minutes"`
	ProductivityScore      int64           `json:"productivity_score"`
	PeakHours              sql.NullString  `json:"peak_hours"`
	TimeByCategory         sql.NullString  `json:"time_by_category"`
	ComputedAt             string          `json:"computed_at"`
}

// Productivity Snapshots
func (q *Queries) CreateProductivitySnapshot(ctx context.Context, arg CreateProductivitySnapshotParams) error {
	_, err := q.db.ExecContext(ctx, createProductivitySnapshot,
		arg.ID,
		arg.UserID,
		arg.SnapshotDate,
		arg.TasksCreated,
		arg.TasksCompleted,
		arg.TasksOverdue,
		arg.TaskCompletionRate,
		arg.AvgTaskDurationMinutes,
		arg.BlocksScheduled,
		arg.BlocksCompleted,
		arg.BlocksMissed,
		arg.ScheduledMinutes,
		arg.CompletedMinutes,
		arg.BlockCompletionRate,
		arg.HabitsDue,
		arg.HabitsCompleted,
		arg.HabitCompletionRate,
		arg.LongestStreak,
		arg.FocusSessions,
		arg.TotalFocusMinutes,
		arg.AvgFocusSessionMinutes,
		arg.ProductivityScore,
		arg.PeakHours,
		arg.TimeByCategory,
		arg.ComputedAt,
	)
	return err
}

const createTimeSession = `-- name: CreateTimeSession :exec

INSERT INTO time_sessions (
    id, user_id, session_type, reference_id, title, category,
    started_at, ended_at, duration_minutes, status, interruptions, notes
) VALUES (
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?
)
`

type CreateTimeSessionParams struct {
	ID              string         `json:"id"`
	UserID          string         `json:"user_id"`
	SessionType     string         `json:"session_type"`
	ReferenceID     sql.NullString `json:"reference_id"`
	Title           string         `json:"title"`
	Category        sql.NullString `json:"category"`
	StartedAt       string         `json:"started_at"`
	EndedAt         sql.NullString `json:"ended_at"`
	DurationMinutes sql.NullInt64  `json:"duration_minutes"`
	Status          string         `json:"status"`
	Interruptions   int64          `json:"interruptions"`
	Notes           sql.NullString `json:"notes"`
}

// Time Sessions
func (q *Queries) CreateTimeSession(ctx context.Context, arg CreateTimeSessionParams) error {
	_, err := q.db.ExecContext(ctx, createTimeSession,
		arg.ID,
		arg.UserID,
		arg.SessionType,
		arg.ReferenceID,
		arg.Title,
		arg.Category,
		arg.StartedAt,
		arg.EndedAt,
		arg.DurationMinutes,
		arg.Status,
		arg.Interruptions,
		arg.Notes,
	)
	return err
}

const createWeeklySummary = `-- name: CreateWeeklySummary :exec

INSERT INTO weekly_summaries (
    id, user_id, week_start, week_end,
    total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes,
    avg_daily_productivity_score, avg_daily_focus_minutes,
    productivity_trend, focus_trend,
    most_productive_day, least_productive_day,
    habits_with_streak, longest_streak, computed_at
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?,
    ?, ?,
    ?, ?,
    ?, ?, ?
)
`

type CreateWeeklySummaryParams struct {
	ID                        string          `json:"id"`
	UserID                    string          `json:"user_id"`
	WeekStart                 string          `json:"week_start"`
	WeekEnd                   string          `json:"week_end"`
	TotalTasksCompleted       int64           `json:"total_tasks_completed"`
	TotalHabitsCompleted      int64           `json:"total_habits_completed"`
	TotalBlocksCompleted      int64           `json:"total_blocks_completed"`
	TotalFocusMinutes         int64           `json:"total_focus_minutes"`
	AvgDailyProductivityScore sql.NullFloat64 `json:"avg_daily_productivity_score"`
	AvgDailyFocusMinutes      sql.NullInt64   `json:"avg_daily_focus_minutes"`
	ProductivityTrend         sql.NullFloat64 `json:"productivity_trend"`
	FocusTrend                sql.NullFloat64 `json:"focus_trend"`
	MostProductiveDay         sql.NullString  `json:"most_productive_day"`
	LeastProductiveDay        sql.NullString  `json:"least_productive_day"`
	HabitsWithStreak          int64           `json:"habits_with_streak"`
	LongestStreak             int64           `json:"longest_streak"`
	ComputedAt                string          `json:"computed_at"`
}

// Weekly Summaries
func (q *Queries) CreateWeeklySummary(ctx context.Context, arg CreateWeeklySummaryParams) error {
	_, err := q.db.ExecContext(ctx, createWeeklySummary,
		arg.ID,
		arg.UserID,
		arg.WeekStart,
		arg.WeekEnd,
		arg.TotalTasksCompleted,
		arg.TotalHabitsCompleted,
		arg.TotalBlocksCompleted,
		arg.TotalFocusMinutes,
		arg.AvgDailyProductivityScore,
		arg.AvgDailyFocusMinutes,
		arg.ProductivityTrend,
		arg.FocusTrend,
		arg.MostProductiveDay,
		arg.LeastProductiveDay,
		arg.HabitsWithStreak,
		arg.LongestStreak,
		arg.ComputedAt,
	)
	return err
}

const deleteProductivityGoal = `-- name: DeleteProductivityGoal :exec
DELETE FROM productivity_goals WHERE id = ?
`

func (q *Queries) DeleteProductivityGoal(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProductivityGoal, id)
	return err
}

const deleteTimeSession = `-- name: DeleteTimeSession :exec
DELETE FROM time_sessions WHERE id = ?
`

func (q *Queries) DeleteTimeSession(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeSession, id)
	return err
}

const getAchievedProductivityGoals = `-- name: GetAchievedProductivityGoals :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = ?
  AND achieved = 1
ORDER BY achieved_at DESC
LIMIT ?
`

type GetAchievedProductivityGoalsParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetAchievedProductivityGoals(ctx context.Context, arg GetAchievedProductivityGoalsParams) ([]ProductivityGoal, error) {
	rows, err := q.db.QueryContext(ctx, getAchievedProductivityGoals, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveProductivityGoals = `-- name: GetActiveProductivityGoals :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = ?
  AND period_end >= date('now')
  AND NOT achieved
ORDER BY period_end ASC
`

func (q *Queries) GetActiveProductivityGoals(ctx context.Context, userID string) ([]ProductivityGoal, error) {
	rows, err := q.db.QueryContext(ctx, getActiveProductivityGoals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveTimeSession = `-- name: GetActiveTimeSession :one
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = ? AND status = 'active'
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveTimeSession(ctx context.Context, userID string) (TimeSession, error) {
	row := q.db.QueryRowContext(ctx, getActiveTimeSession, userID)
	var i TimeSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ReferenceID,
		&i.Title,
		&i.Category,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationMinutes,
		&i.Status,
		&i.Interruptions,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAverageProductivityScore = `-- name: GetAverageProductivityScore :one
SELECT CAST(COALESCE(AVG(productivity_score), 0) AS INTEGER) as avg_score
FROM productivity_snapshots
WHERE user_id = ?
  AND snapshot_date >= ?
  AND snapshot_date <= ?
`

type GetAverageProductivityScoreParams struct {
	UserID         string `json:"user_id"`
	SnapshotDate   string `json:"snapshot_date"`
	SnapshotDate_2 string `json:"snapshot_date_2"`
}

func (q *Queries) GetAverageProductivityScore(ctx context.Context, arg GetAverageProductivityScoreParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAverageProductivityScore, arg.UserID, arg.SnapshotDate, arg.SnapshotDate_2)
	var avg_score int64
	err := row.Scan(&avg_score)
	return avg_score, err
}

const getHabitCompletionsByDateRange = `-- name: GetHabitCompletionsByDateRange :one
SELECT COUNT(*) as completions
FROM habit_completions hc
JOIN habits h ON h.id = hc.habit_id
WHERE h.user_id = ?
  AND hc.completed_at >= ?
  AND hc.completed_at < ?
`

type GetHabitCompletionsByDateRangeParams struct {
	UserID        string `json:"user_id"`
	CompletedAt   string `json:"completed_at"`
	CompletedAt_2 string `json:"completed_at_2"`
}

func (q *Queries) GetHabitCompletionsByDateRange(ctx context.Context, arg GetHabitCompletionsByDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHabitCompletionsByDateRange, arg.UserID, arg.CompletedAt, arg.CompletedAt_2)
	var completions int64
	err := row.Scan(&completions)
	return completions, err
}

const getHabitsDueCount = `-- name: GetHabitsDueCount :one
SELECT COUNT(*) as due_count
FROM habits
WHERE user_id = ?
  AND archived = 0
`

func (q *Queries) GetHabitsDueCount(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getHabitsDueCount, userID)
	var due_count int64
	err := row.Scan(&due_count)
	return due_count, err
}

const getLatestProductivitySnapshot = `-- name: GetLatestProductivitySnapshot :one
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = ?
ORDER BY snapshot_date DESC
LIMIT 1
`

func (q *Queries) GetLatestProductivitySnapshot(ctx context.Context, userID string) (ProductivitySnapshot, error) {
	row := q.db.QueryRowContext(ctx, getLatestProductivitySnapshot, userID)
	var i ProductivitySnapshot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SnapshotDate,
		&i.TasksCreated,
		&i.TasksCompleted,
		&i.TasksOverdue,
		&i.TaskCompletionRate,
		&i.AvgTaskDurationMinutes,
		&i.BlocksScheduled,
		&i.BlocksCompleted,
		&i.BlocksMissed,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
		&i.BlockCompletionRate,
		&i.HabitsDue,
		&i.HabitsCompleted,
		&i.HabitCompletionRate,
		&i.LongestStreak,
		&i.FocusSessions,
		&i.TotalFocusMinutes,
		&i.AvgFocusSessionMinutes,
		&i.ProductivityScore,
		&i.PeakHours,
		&i.TimeByCategory,
		&i.ComputedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLatestWeeklySummary = `-- name: GetLatestWeeklySummary :one
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = ?
ORDER BY week_start DESC
LIMIT 1
`

func (q *Queries) GetLatestWeeklySummary(ctx context.Context, userID string) (WeeklySummary, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeeklySummary, userID)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.TotalTasksCompleted,
		&i.TotalHabitsCompleted,
		&i.TotalBlocksCompleted,
		&i.TotalFocusMinutes,
		&i.AvgDailyProductivityScore,
		&i.AvgDailyFocusMinutes,
		&i.ProductivityTrend,
		&i.FocusTrend,
		&i.MostProductiveDay,
		&i.LeastProductiveDay,
		&i.HabitsWithStreak,
		&i.LongestStreak,
		&i.ComputedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getLongestActiveStreak = `-- name: GetLongestActiveStreak :one
SELECT CAST(COALESCE(MAX(streak), 0) AS INTEGER) as longest_streak
FROM habits
WHERE user_id = ?
  AND archived = 0
`

func (q *Queries) GetLongestActiveStreak(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getLongestActiveStreak, userID)
	var longest_streak int64
	err := row.Scan(&longest_streak)
	return longest_streak, err
}

const getPeakProductivityHours = `-- name: GetPeakProductivityHours :many
SELECT
    CAST(strftime('%H', completed_at) AS INTEGER) as hour,
    COUNT(*) as completions
FROM tasks
WHERE user_id = ?
  AND completed_at >= ?
  AND completed_at < ?
  AND completed_at IS NOT NULL
GROUP BY strftime('%H', completed_at)
ORDER BY completions DESC
LIMIT 5
`

type GetPeakProductivityHoursParams struct {
	UserID        string         `json:"user_id"`
	CompletedAt   sql.NullString `json:"completed_at"`
	CompletedAt_2 sql.NullString `json:"completed_at_2"`
}

type GetPeakProductivityHoursRow struct {
	Hour        int64 `json:"hour"`
	Completions int64 `json:"completions"`
}

func (q *Queries) GetPeakProductivityHours(ctx context.Context, arg GetPeakProductivityHoursParams) ([]GetPeakProductivityHoursRow, error) {
	rows, err := q.db.QueryContext(ctx, getPeakProductivityHours, arg.UserID, arg.CompletedAt, arg.CompletedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPeakProductivityHoursRow{}
	for rows.Next() {
		var i GetPeakProductivityHoursRow
		if err := rows.Scan(&i.Hour, &i.Completions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityGoal = `-- name: GetProductivityGoal :one
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals WHERE id = ?
`

func (q *Queries) GetProductivityGoal(ctx context.Context, id string) (ProductivityGoal, error) {
	row := q.db.QueryRowContext(ctx, getProductivityGoal, id)
	var i ProductivityGoal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GoalType,
		&i.TargetValue,
		&i.CurrentValue,
		&i.PeriodType,
		&i.PeriodStart,
		&i.PeriodEnd,
		&i.Achieved,
		&i.AchievedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductivityGoalsByPeriod = `-- name: GetProductivityGoalsByPeriod :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = ?
  AND period_start >= ?
  AND period_end <= ?
ORDER BY period_start ASC
`

type GetProductivityGoalsByPeriodParams struct {
	UserID      string `json:"user_id"`
	PeriodStart string `json:"period_start"`
	PeriodEnd   string `json:"period_end"`
}

func (q *Queries) GetProductivityGoalsByPeriod(ctx context.Context, arg GetProductivityGoalsByPeriodParams) ([]ProductivityGoal, error) {
	rows, err := q.db.QueryContext(ctx, getProductivityGoalsByPeriod, arg.UserID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityGoalsByType = `-- name: GetProductivityGoalsByType :many
SELECT id, user_id, goal_type, target_value, current_value, period_type, period_start, period_end, achieved, achieved_at, created_at, updated_at FROM productivity_goals
WHERE user_id = ? AND goal_type = ?
ORDER BY period_start DESC
`

type GetProductivityGoalsByTypeParams struct {
	UserID   string `json:"user_id"`
	GoalType string `json:"goal_type"`
}

func (q *Queries) GetProductivityGoalsByType(ctx context.Context, arg GetProductivityGoalsByTypeParams) ([]ProductivityGoal, error) {
	rows, err := q.db.QueryContext(ctx, getProductivityGoalsByType, arg.UserID, arg.GoalType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivityGoal{}
	for rows.Next() {
		var i ProductivityGoal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalType,
			&i.TargetValue,
			&i.CurrentValue,
			&i.PeriodType,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Achieved,
			&i.AchievedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivitySnapshot = `-- name: GetProductivitySnapshot :one
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = ? AND snapshot_date = ?
`

type GetProductivitySnapshotParams struct {
	UserID       string `json:"user_id"`
	SnapshotDate string `json:"snapshot_date"`
}

func (q *Queries) GetProductivitySnapshot(ctx context.Context, arg GetProductivitySnapshotParams) (ProductivitySnapshot, error) {
	row := q.db.QueryRowContext(ctx, getProductivitySnapshot, arg.UserID, arg.SnapshotDate)
	var i ProductivitySnapshot
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SnapshotDate,
		&i.TasksCreated,
		&i.TasksCompleted,
		&i.TasksOverdue,
		&i.TaskCompletionRate,
		&i.AvgTaskDurationMinutes,
		&i.BlocksScheduled,
		&i.BlocksCompleted,
		&i.BlocksMissed,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
		&i.BlockCompletionRate,
		&i.HabitsDue,
		&i.HabitsCompleted,
		&i.HabitCompletionRate,
		&i.LongestStreak,
		&i.FocusSessions,
		&i.TotalFocusMinutes,
		&i.AvgFocusSessionMinutes,
		&i.ProductivityScore,
		&i.PeakHours,
		&i.TimeByCategory,
		&i.ComputedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductivitySnapshotRange = `-- name: GetProductivitySnapshotRange :many
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = ?
  AND snapshot_date >= ?
  AND snapshot_date <= ?
ORDER BY snapshot_date DESC
`

type GetProductivitySnapshotRangeParams struct {
	UserID         string `json:"user_id"`
	SnapshotDate   string `json:"snapshot_date"`
	SnapshotDate_2 string `json:"snapshot_date_2"`
}

func (q *Queries) GetProductivitySnapshotRange(ctx context.Context, arg GetProductivitySnapshotRangeParams) ([]ProductivitySnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getProductivitySnapshotRange, arg.UserID, arg.SnapshotDate, arg.SnapshotDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivitySnapshot{}
	for rows.Next() {
		var i ProductivitySnapshot
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SnapshotDate,
			&i.TasksCreated,
			&i.TasksCompleted,
			&i.TasksOverdue,
			&i.TaskCompletionRate,
			&i.AvgTaskDurationMinutes,
			&i.BlocksScheduled,
			&i.BlocksCompleted,
			&i.BlocksMissed,
			&i.ScheduledMinutes,
			&i.CompletedMinutes,
			&i.BlockCompletionRate,
			&i.HabitsDue,
			&i.HabitsCompleted,
			&i.HabitCompletionRate,
			&i.LongestStreak,
			&i.FocusSessions,
			&i.TotalFocusMinutes,
			&i.AvgFocusSessionMinutes,
			&i.ProductivityScore,
			&i.PeakHours,
			&i.TimeByCategory,
			&i.ComputedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivitySnapshots = `-- name: GetProductivitySnapshots :many
SELECT id, user_id, snapshot_date, tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes, blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate, habits_due, habits_completed, habit_completion_rate, longest_streak, focus_sessions, total_focus_minutes, avg_focus_session_minutes, productivity_score, peak_hours, time_by_category, computed_at, created_at, updated_at FROM productivity_snapshots
WHERE user_id = ?
ORDER BY snapshot_date DESC
LIMIT ?
`

type GetProductivitySnapshotsParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetProductivitySnapshots(ctx context.Context, arg GetProductivitySnapshotsParams) ([]ProductivitySnapshot, error) {
	rows, err := q.db.QueryContext(ctx, getProductivitySnapshots, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductivitySnapshot{}
	for rows.Next() {
		var i ProductivitySnapshot
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SnapshotDate,
			&i.TasksCreated,
			&i.TasksCompleted,
			&i.TasksOverdue,
			&i.TaskCompletionRate,
			&i.AvgTaskDurationMinutes,
			&i.BlocksScheduled,
			&i.BlocksCompleted,
			&i.BlocksMissed,
			&i.ScheduledMinutes,
			&i.CompletedMinutes,
			&i.BlockCompletionRate,
			&i.HabitsDue,
			&i.HabitsCompleted,
			&i.HabitCompletionRate,
			&i.LongestStreak,
			&i.FocusSessions,
			&i.TotalFocusMinutes,
			&i.AvgFocusSessionMinutes,
			&i.ProductivityScore,
			&i.PeakHours,
			&i.TimeByCategory,
			&i.ComputedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskCompletionsByDateRange = `-- name: GetTaskCompletionsByDateRange :one

SELECT
    SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
    SUM(CASE WHEN status = 'pending' AND due_date < datetime('now') THEN 1 ELSE 0 END) as overdue,
    COUNT(*) as total
FROM tasks
WHERE user_id = ?
  AND created_at >= ?
  AND created_at < ?
`

type GetTaskCompletionsByDateRangeParams struct {
	UserID      string `json:"user_id"`
	CreatedAt   string `json:"created_at"`
	CreatedAt_2 string `json:"created_at_2"`
}

type GetTaskCompletionsByDateRangeRow struct {
	Completed sql.NullFloat64 `json:"completed"`
	Overdue   sql.NullFloat64 `json:"overdue"`
	Total     int64           `json:"total"`
}

// Analytics queries using existing tables
func (q *Queries) GetTaskCompletionsByDateRange(ctx context.Context, arg GetTaskCompletionsByDateRangeParams) (GetTaskCompletionsByDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getTaskCompletionsByDateRange, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	var i GetTaskCompletionsByDateRangeRow
	err := row.Scan(&i.Completed, &i.Overdue, &i.Total)
	return i, err
}

const getTimeBlockStatsByDateRange = `-- name: GetTimeBlockStatsByDateRange :one
SELECT
    COUNT(*) as total_blocks,
    SUM(CASE WHEN completed = 1 THEN 1 ELSE 0 END) as completed_blocks,
    SUM(CASE WHEN missed = 1 THEN 1 ELSE 0 END) as missed_blocks,
    CAST(COALESCE(SUM((julianday(end_time) - julianday(start_time)) * 24 * 60), 0) AS INTEGER) as scheduled_minutes,
    CAST(COALESCE(SUM(CASE WHEN completed = 1 THEN (julianday(end_time) - julianday(start_time)) * 24 * 60 ELSE 0 END), 0) AS INTEGER) as completed_minutes
FROM time_blocks
WHERE user_id = ?
  AND start_time >= ?
  AND start_time < ?
`

type GetTimeBlockStatsByDateRangeParams struct {
	UserID      string `json:"user_id"`
	StartTime   string `json:"start_time"`
	StartTime_2 string `json:"start_time_2"`
}

type GetTimeBlockStatsByDateRangeRow struct {
	TotalBlocks      int64           `json:"total_blocks"`
	CompletedBlocks  sql.NullFloat64 `json:"completed_blocks"`
	MissedBlocks     sql.NullFloat64 `json:"missed_blocks"`
	ScheduledMinutes int64           `json:"scheduled_minutes"`
	CompletedMinutes int64           `json:"completed_minutes"`
}

func (q *Queries) GetTimeBlockStatsByDateRange(ctx context.Context, arg GetTimeBlockStatsByDateRangeParams) (GetTimeBlockStatsByDateRangeRow, error) {
	row := q.db.QueryRowContext(ctx, getTimeBlockStatsByDateRange, arg.UserID, arg.StartTime, arg.StartTime_2)
	var i GetTimeBlockStatsByDateRangeRow
	err := row.Scan(
		&i.TotalBlocks,
		&i.CompletedBlocks,
		&i.MissedBlocks,
		&i.ScheduledMinutes,
		&i.CompletedMinutes,
	)
	return i, err
}

const getTimeByBlockType = `-- name: GetTimeByBlockType :many
SELECT
    block_type as category,
    CAST(COALESCE(SUM((julianday(end_time) - julianday(start_time)) * 24 * 60), 0) AS INTEGER) as minutes
FROM time_blocks
WHERE user_id = ?
  AND start_time >= ?
  AND start_time < ?
  AND completed = 1
GROUP BY block_type
ORDER BY minutes DESC
`

type GetTimeByBlockTypeParams struct {
	UserID      string `json:"user_id"`
	StartTime   string `json:"start_time"`
	StartTime_2 string `json:"start_time_2"`
}

type GetTimeByBlockTypeRow struct {
	Category string `json:"category"`
	Minutes  int64  `json:"minutes"`
}

func (q *Queries) GetTimeByBlockType(ctx context.Context, arg GetTimeByBlockTypeParams) ([]GetTimeByBlockTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getTimeByBlockType, arg.UserID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTimeByBlockTypeRow{}
	for rows.Next() {
		var i GetTimeByBlockTypeRow
		if err := rows.Scan(&i.Category, &i.Minutes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSession = `-- name: GetTimeSession :one
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions WHERE id = ?
`

func (q *Queries) GetTimeSession(ctx context.Context, id string) (TimeSession, error) {
	row := q.db.QueryRowContext(ctx, getTimeSession, id)
	var i TimeSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionType,
		&i.ReferenceID,
		&i.Title,
		&i.Category,
		&i.StartedAt,
		&i.EndedAt,
		&i.DurationMinutes,
		&i.Status,
		&i.Interruptions,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimeSessionsByDateRange = `-- name: GetTimeSessionsByDateRange :many
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = ?
  AND started_at >= ?
  AND started_at < ?
ORDER BY started_at DESC
`

type GetTimeSessionsByDateRangeParams struct {
	UserID      string `json:"user_id"`
	StartedAt   string `json:"started_at"`
	StartedAt_2 string `json:"started_at_2"`
}

func (q *Queries) GetTimeSessionsByDateRange(ctx context.Context, arg GetTimeSessionsByDateRangeParams) ([]TimeSession, error) {
	rows, err := q.db.QueryContext(ctx, getTimeSessionsByDateRange, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeSession{}
	for rows.Next() {
		var i TimeSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ReferenceID,
			&i.Title,
			&i.Category,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationMinutes,
			&i.Status,
			&i.Interruptions,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSessionsByType = `-- name: GetTimeSessionsByType :many
SELECT id, user_id, session_type, reference_id, title, category, started_at, ended_at, duration_minutes, status, interruptions, notes, created_at, updated_at FROM time_sessions
WHERE user_id = ? AND session_type = ?
ORDER BY started_at DESC
LIMIT ?
`

type GetTimeSessionsByTypeParams struct {
	UserID      string `json:"user_id"`
	SessionType string `json:"session_type"`
	Limit       int64  `json:"limit"`
}

func (q *Queries) GetTimeSessionsByType(ctx context.Context, arg GetTimeSessionsByTypeParams) ([]TimeSession, error) {
	rows, err := q.db.QueryContext(ctx, getTimeSessionsByType, arg.UserID, arg.SessionType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TimeSession{}
	for rows.Next() {
		var i TimeSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionType,
			&i.ReferenceID,
			&i.Title,
			&i.Category,
			&i.StartedAt,
			&i.EndedAt,
			&i.DurationMinutes,
			&i.Status,
			&i.Interruptions,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalFocusMinutesByDateRange = `-- name: GetTotalFocusMinutesByDateRange :one
SELECT CAST(COALESCE(SUM(duration_minutes), 0) AS INTEGER) as total_minutes
FROM time_sessions
WHERE user_id = ?
  AND session_type = 'focus'
  AND status = 'completed'
  AND started_at >= ?
  AND started_at < ?
`

type GetTotalFocusMinutesByDateRangeParams struct {
	UserID      string `json:"user_id"`
	StartedAt   string `json:"started_at"`
	StartedAt_2 string `json:"started_at_2"`
}

func (q *Queries) GetTotalFocusMinutesByDateRange(ctx context.Context, arg GetTotalFocusMinutesByDateRangeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalFocusMinutesByDateRange, arg.UserID, arg.StartedAt, arg.StartedAt_2)
	var total_minutes int64
	err := row.Scan(&total_minutes)
	return total_minutes, err
}

const getWeeklySummaries = `-- name: GetWeeklySummaries :many
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = ?
ORDER BY week_start DESC
LIMIT ?
`

type GetWeeklySummariesParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetWeeklySummaries(ctx context.Context, arg GetWeeklySummariesParams) ([]WeeklySummary, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklySummaries, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WeeklySummary{}
	for rows.Next() {
		var i WeeklySummary
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WeekStart,
			&i.WeekEnd,
			&i.TotalTasksCompleted,
			&i.TotalHabitsCompleted,
			&i.TotalBlocksCompleted,
			&i.TotalFocusMinutes,
			&i.AvgDailyProductivityScore,
			&i.AvgDailyFocusMinutes,
			&i.ProductivityTrend,
			&i.FocusTrend,
			&i.MostProductiveDay,
			&i.LeastProductiveDay,
			&i.HabitsWithStreak,
			&i.LongestStreak,
			&i.ComputedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklySummary = `-- name: GetWeeklySummary :one
SELECT id, user_id, week_start, week_end, total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes, avg_daily_productivity_score, avg_daily_focus_minutes, productivity_trend, focus_trend, most_productive_day, least_productive_day, habits_with_streak, longest_streak, computed_at, created_at FROM weekly_summaries
WHERE user_id = ? AND week_start = ?
`

type GetWeeklySummaryParams struct {
	UserID    string `json:"user_id"`
	WeekStart string `json:"week_start"`
}

func (q *Queries) GetWeeklySummary(ctx context.Context, arg GetWeeklySummaryParams) (WeeklySummary, error) {
	row := q.db.QueryRowContext(ctx, getWeeklySummary, arg.UserID, arg.WeekStart)
	var i WeeklySummary
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WeekStart,
		&i.WeekEnd,
		&i.TotalTasksCompleted,
		&i.TotalHabitsCompleted,
		&i.TotalBlocksCompleted,
		&i.TotalFocusMinutes,
		&i.AvgDailyProductivityScore,
		&i.AvgDailyFocusMinutes,
		&i.ProductivityTrend,
		&i.FocusTrend,
		&i.MostProductiveDay,
		&i.LeastProductiveDay,
		&i.HabitsWithStreak,
		&i.LongestStreak,
		&i.ComputedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductivityGoal = `-- name: UpdateProductivityGoal :exec
UPDATE productivity_goals SET
    current_value = ?,
    achieved = ?,
    achieved_at = ?
WHERE id = ?
`

type UpdateProductivityGoalParams struct {
	CurrentValue int64          `json:"current_value"`
	Achieved     int64          `json:"achieved"`
	AchievedAt   sql.NullString `json:"achieved_at"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateProductivityGoal(ctx context.Context, arg UpdateProductivityGoalParams) error {
	_, err := q.db.ExecContext(ctx, updateProductivityGoal,
		arg.CurrentValue,
		arg.Achieved,
		arg.AchievedAt,
		arg.ID,
	)
	return err
}

const updateTimeSession = `-- name: UpdateTimeSession :exec
UPDATE time_sessions SET
    ended_at = ?,
    duration_minutes = ?,
    status = ?,
    interruptions = ?,
    notes = ?
WHERE id = ?
`

type UpdateTimeSessionParams struct {
	EndedAt         sql.NullString `json:"ended_at"`
	DurationMinutes sql.NullInt64  `json:"duration_minutes"`
	Status          string         `json:"status"`
	Interruptions   int64          `json:"interruptions"`
	Notes           sql.NullString `json:"notes"`
	ID              string         `json:"id"`
}

func (q *Queries) UpdateTimeSession(ctx context.Context, arg UpdateTimeSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateTimeSession,
		arg.EndedAt,
		arg.DurationMinutes,
		arg.Status,
		arg.Interruptions,
		arg.Notes,
		arg.ID,
	)
	return err
}

const upsertProductivitySnapshot = `-- name: UpsertProductivitySnapshot :exec
INSERT INTO productivity_snapshots (
    id, user_id, snapshot_date,
    tasks_created, tasks_completed, tasks_overdue, task_completion_rate, avg_task_duration_minutes,
    blocks_scheduled, blocks_completed, blocks_missed, scheduled_minutes, completed_minutes, block_completion_rate,
    habits_due, habits_completed, habit_completion_rate, longest_streak,
    focus_sessions, total_focus_minutes, avg_focus_session_minutes,
    productivity_score, peak_hours, time_by_category, computed_at
) VALUES (
    ?, ?, ?,
    ?, ?, ?, ?, ?,
    ?, ?, ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?, ?,
    ?, ?, ?, ?
)
ON CONFLICT (user_id, snapshot_date)
DO UPDATE SET
    tasks_created = excluded.tasks_created,
    tasks_completed = excluded.tasks_completed,
    tasks_overdue = excluded.tasks_overdue,
    task_completion_rate = excluded.task_completion_rate,
    avg_task_duration_minutes = excluded.avg_task_duration_minutes,
    blocks_scheduled = excluded.blocks_scheduled,
    blocks_completed = excluded.blocks_completed,
    blocks_missed = excluded.blocks_missed,
    scheduled_minutes = excluded.scheduled_minutes,
    completed_minutes = excluded.completed_minutes,
    block_completion_rate = excluded.block_completion_rate,
    habits_due = excluded.habits_due,
    habits_completed = excluded.habits_completed,
    habit_completion_rate = excluded.habit_completion_rate,
    longest_streak = excluded.longest_streak,
    focus_sessions = excluded.focus_sessions,
    total_focus_minutes = excluded.total_focus_minutes,
    avg_focus_session_minutes = excluded.avg_focus_session_minutes,
    productivity_score = excluded.productivity_score,
    peak_hours = excluded.peak_hours,
    time_by_category = excluded.time_by_category,
    computed_at = excluded.computed_at,
    updated_at = datetime('now')
`

type UpsertProductivitySnapshotParams struct {
	ID                     string          `json:"id"`
	UserID                 string          `json:"user_id"`
	SnapshotDate           string          `json:"snapshot_date"`
	TasksCreated           int64           `json:"tasks_created"`
	TasksCompleted         int64           `json:"tasks_completed"`
	TasksOverdue           int64           `json:"tasks_overdue"`
	TaskCompletionRate     sql.NullFloat64 `json:"task_completion_rate"`
	AvgTaskDurationMinutes sql.NullInt64   `json:"avg_task_duration_minutes"`
	BlocksScheduled        int64           `json:"blocks_scheduled"`
	BlocksCompleted        int64           `json:"blocks_completed"`
	BlocksMissed           int64           `json:"blocks_missed"`
	ScheduledMinutes       int64           `json:"scheduled_minutes"`
	CompletedMinutes       int64           `json:"completed_minutes"`
	BlockCompletionRate    sql.NullFloat64 `json:"block_completion_rate"`
	HabitsDue              int64           `json:"habits_due"`
	HabitsCompleted        int64           `json:"habits_completed"`
	HabitCompletionRate    sql.NullFloat64 `json:"habit_completion_rate"`
	LongestStreak          int64           `json:"longest_streak"`
	FocusSessions          int64           `json:"focus_sessions"`
	TotalFocusMinutes      int64           `json:"total_focus_minutes"`
	AvgFocusSessionMinutes sql.NullInt64   `json:"avg_focus_session_minutes"`
	ProductivityScore      int64           `json:"productivity_score"`
	PeakHours              sql.NullString  `json:"peak_hours"`
	TimeByCategory         sql.NullString  `json:"time_by_category"`
	ComputedAt             string          `json:"computed_at"`
}

func (q *Queries) UpsertProductivitySnapshot(ctx context.Context, arg UpsertProductivitySnapshotParams) error {
	_, err := q.db.ExecContext(ctx, upsertProductivitySnapshot,
		arg.ID,
		arg.UserID,
		arg.SnapshotDate,
		arg.TasksCreated,
		arg.TasksCompleted,
		arg.TasksOverdue,
		arg.TaskCompletionRate,
		arg.AvgTaskDurationMinutes,
		arg.BlocksScheduled,
		arg.BlocksCompleted,
		arg.BlocksMissed,
		arg.ScheduledMinutes,
		arg.CompletedMinutes,
		arg.BlockCompletionRate,
		arg.HabitsDue,
		arg.HabitsCompleted,
		arg.HabitCompletionRate,
		arg.LongestStreak,
		arg.FocusSessions,
		arg.TotalFocusMinutes,
		arg.AvgFocusSessionMinutes,
		arg.ProductivityScore,
		arg.PeakHours,
		arg.TimeByCategory,
		arg.ComputedAt,
	)
	return err
}

const upsertWeeklySummary = `-- name: UpsertWeeklySummary :exec
INSERT INTO weekly_summaries (
    id, user_id, week_start, week_end,
    total_tasks_completed, total_habits_completed, total_blocks_completed, total_focus_minutes,
    avg_daily_productivity_score, avg_daily_focus_minutes,
    productivity_trend, focus_trend,
    most_productive_day, least_productive_day,
    habits_with_streak, longest_streak, computed_at
) VALUES (
    ?, ?, ?, ?,
    ?, ?, ?, ?,
    ?, ?,
    ?, ?,
    ?, ?,
    ?, ?, ?
)
ON CONFLICT (user_id, week_start)
DO UPDATE SET
    total_tasks_completed = excluded.total_tasks_completed,
    total_habits_completed = excluded.total_habits_completed,
    total_blocks_completed = excluded.total_blocks_completed,
    total_focus_minutes = excluded.total_focus_minutes,
    avg_daily_productivity_score = excluded.avg_daily_productivity_score,
    avg_daily_focus_minutes = excluded.avg_daily_focus_minutes,
    productivity_trend = excluded.productivity_trend,
    focus_trend = excluded.focus_trend,
    most_productive_day = excluded.most_productive_day,
    least_productive_day = excluded.least_productive_day,
    habits_with_streak = excluded.habits_with_streak,
    longest_streak = excluded.longest_streak,
    computed_at = excluded.computed_at
`

type UpsertWeeklySummaryParams struct {
	ID                        string          `json:"id"`
	UserID                    string          `json:"user_id"`
	WeekStart                 string          `json:"week_start"`
	WeekEnd                   string          `json:"week_end"`
	TotalTasksCompleted       int64           `json:"total_tasks_completed"`
	TotalHabitsCompleted      int64           `json:"total_habits_completed"`
	TotalBlocksCompleted      int64           `json:"total_blocks_completed"`
	TotalFocusMinutes         int64           `json:"total_focus_minutes"`
	AvgDailyProductivityScore sql.NullFloat64 `json:"avg_daily_productivity_score"`
	AvgDailyFocusMinutes      sql.NullInt64   `json:"avg_daily_focus_minutes"`
	ProductivityTrend         sql.NullFloat64 `json:"productivity_trend"`
	FocusTrend                sql.NullFloat64 `json:"focus_trend"`
	MostProductiveDay         sql.NullString  `json:"most_productive_day"`
	LeastProductiveDay        sql.NullString  `json:"least_productive_day"`
	HabitsWithStreak          int64           `json:"habits_with_streak"`
	LongestStreak             int64           `json:"longest_streak"`
	ComputedAt                string          `json:"computed_at"`
}

func (q *Queries) UpsertWeeklySummary(ctx context.Context, arg UpsertWeeklySummaryParams) error {
	_, err := q.db.ExecContext(ctx, upsertWeeklySummary,
		arg.ID,
		arg.UserID,
		arg.WeekStart,
		arg.WeekEnd,
		arg.TotalTasksCompleted,
		arg.TotalHabitsCompleted,
		arg.TotalBlocksCompleted,
		arg.TotalFocusMinutes,
		arg.AvgDailyProductivityScore,
		arg.AvgDailyFocusMinutes,
		arg.ProductivityTrend,
		arg.FocusTrend,
		arg.MostProductiveDay,
		arg.LeastProductiveDay,
		arg.HabitsWithStreak,
		arg.LongestStreak,
		arg.ComputedAt,
	)
	return err
}
