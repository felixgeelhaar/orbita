// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMilestone = `-- name: CreateMilestone :one

INSERT INTO milestones (
    id, project_id, name, description, due_date,
    status, progress, display_order, created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at
`

type CreateMilestoneParams struct {
	ID           pgtype.UUID        `json:"id"`
	ProjectID    pgtype.UUID        `json:"project_id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DueDate      pgtype.Timestamptz `json:"due_date"`
	Status       string             `json:"status"`
	Progress     pgtype.Numeric     `json:"progress"`
	DisplayOrder int32              `json:"display_order"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Milestones
func (q *Queries) CreateMilestone(ctx context.Context, arg CreateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRow(ctx, createMilestone,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Status,
		arg.Progress,
		arg.DisplayOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMilestoneTaskLink = `-- name: CreateMilestoneTaskLink :exec

INSERT INTO milestone_task_links (milestone_id, task_id, role, display_order, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateMilestoneTaskLinkParams struct {
	MilestoneID  pgtype.UUID `json:"milestone_id"`
	TaskID       pgtype.UUID `json:"task_id"`
	Role         string      `json:"role"`
	DisplayOrder int32       `json:"display_order"`
}

// Milestone Task Links
func (q *Queries) CreateMilestoneTaskLink(ctx context.Context, arg CreateMilestoneTaskLinkParams) error {
	_, err := q.db.Exec(ctx, createMilestoneTaskLink,
		arg.MilestoneID,
		arg.TaskID,
		arg.Role,
		arg.DisplayOrder,
	)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    id, user_id, name, description, status,
    start_date, due_date, health_overall, health_on_track,
    health_risk_factors, health_last_updated, metadata,
    created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at
`

type CreateProjectParams struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	Name              string             `json:"name"`
	Description       pgtype.Text        `json:"description"`
	Status            string             `json:"status"`
	StartDate         pgtype.Timestamptz `json:"start_date"`
	DueDate           pgtype.Timestamptz `json:"due_date"`
	HealthOverall     pgtype.Numeric     `json:"health_overall"`
	HealthOnTrack     bool               `json:"health_on_track"`
	HealthRiskFactors []byte             `json:"health_risk_factors"`
	HealthLastUpdated pgtype.Timestamptz `json:"health_last_updated"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.StartDate,
		arg.DueDate,
		arg.HealthOverall,
		arg.HealthOnTrack,
		arg.HealthRiskFactors,
		arg.HealthLastUpdated,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectTaskLink = `-- name: CreateProjectTaskLink :exec

INSERT INTO project_task_links (project_id, task_id, role, display_order, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateProjectTaskLinkParams struct {
	ProjectID    pgtype.UUID `json:"project_id"`
	TaskID       pgtype.UUID `json:"task_id"`
	Role         string      `json:"role"`
	DisplayOrder int32       `json:"display_order"`
}

// Project Task Links
func (q *Queries) CreateProjectTaskLink(ctx context.Context, arg CreateProjectTaskLinkParams) error {
	_, err := q.db.Exec(ctx, createProjectTaskLink,
		arg.ProjectID,
		arg.TaskID,
		arg.Role,
		arg.DisplayOrder,
	)
	return err
}

const deleteAllMilestoneTaskLinks = `-- name: DeleteAllMilestoneTaskLinks :exec
DELETE FROM milestone_task_links WHERE milestone_id = $1
`

func (q *Queries) DeleteAllMilestoneTaskLinks(ctx context.Context, milestoneID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllMilestoneTaskLinks, milestoneID)
	return err
}

const deleteAllProjectTaskLinks = `-- name: DeleteAllProjectTaskLinks :exec
DELETE FROM project_task_links WHERE project_id = $1
`

func (q *Queries) DeleteAllProjectTaskLinks(ctx context.Context, projectID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllProjectTaskLinks, projectID)
	return err
}

const deleteMilestone = `-- name: DeleteMilestone :exec
DELETE FROM milestones WHERE id = $1
`

func (q *Queries) DeleteMilestone(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMilestone, id)
	return err
}

const deleteMilestoneTaskLink = `-- name: DeleteMilestoneTaskLink :exec
DELETE FROM milestone_task_links WHERE milestone_id = $1 AND task_id = $2
`

type DeleteMilestoneTaskLinkParams struct {
	MilestoneID pgtype.UUID `json:"milestone_id"`
	TaskID      pgtype.UUID `json:"task_id"`
}

func (q *Queries) DeleteMilestoneTaskLink(ctx context.Context, arg DeleteMilestoneTaskLinkParams) error {
	_, err := q.db.Exec(ctx, deleteMilestoneTaskLink, arg.MilestoneID, arg.TaskID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = $1 AND user_id = $2
`

type DeleteProjectParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.ID, arg.UserID)
	return err
}

const deleteProjectTaskLink = `-- name: DeleteProjectTaskLink :exec
DELETE FROM project_task_links WHERE project_id = $1 AND task_id = $2
`

type DeleteProjectTaskLinkParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	TaskID    pgtype.UUID `json:"task_id"`
}

func (q *Queries) DeleteProjectTaskLink(ctx context.Context, arg DeleteProjectTaskLinkParams) error {
	_, err := q.db.Exec(ctx, deleteProjectTaskLink, arg.ProjectID, arg.TaskID)
	return err
}

const getActiveProjects = `-- name: GetActiveProjects :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = $1 AND status NOT IN ('completed', 'archived')
ORDER BY
    CASE WHEN due_date IS NULL THEN 1 ELSE 0 END,
    due_date,
    created_at DESC
`

func (q *Queries) GetActiveProjects(ctx context.Context, userID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMilestoneByID = `-- name: GetMilestoneByID :one
SELECT id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at FROM milestones WHERE id = $1
`

func (q *Queries) GetMilestoneByID(ctx context.Context, id pgtype.UUID) (Milestone, error) {
	row := q.db.QueryRow(ctx, getMilestoneByID, id)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMilestoneTaskLinks = `-- name: GetMilestoneTaskLinks :many
SELECT milestone_id, task_id, role, display_order, created_at FROM milestone_task_links
WHERE milestone_id = $1
ORDER BY display_order
`

func (q *Queries) GetMilestoneTaskLinks(ctx context.Context, milestoneID pgtype.UUID) ([]MilestoneTaskLink, error) {
	rows, err := q.db.Query(ctx, getMilestoneTaskLinks, milestoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MilestoneTaskLink{}
	for rows.Next() {
		var i MilestoneTaskLink
		if err := rows.Scan(
			&i.MilestoneID,
			&i.TaskID,
			&i.Role,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMilestonesByProjectID = `-- name: GetMilestonesByProjectID :many
SELECT id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at FROM milestones
WHERE project_id = $1
ORDER BY display_order, due_date
`

func (q *Queries) GetMilestonesByProjectID(ctx context.Context, projectID pgtype.UUID) ([]Milestone, error) {
	rows, err := q.db.Query(ctx, getMilestonesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Milestone{}
	for rows.Next() {
		var i Milestone
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.DueDate,
			&i.Status,
			&i.Progress,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects WHERE id = $1 AND user_id = $2
`

type GetProjectByIDParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetProjectByID(ctx context.Context, arg GetProjectByIDParams) (Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, arg.ID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectTaskLinks = `-- name: GetProjectTaskLinks :many
SELECT project_id, task_id, role, display_order, created_at FROM project_task_links
WHERE project_id = $1
ORDER BY display_order
`

func (q *Queries) GetProjectTaskLinks(ctx context.Context, projectID pgtype.UUID) ([]ProjectTaskLink, error) {
	rows, err := q.db.Query(ctx, getProjectTaskLinks, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectTaskLink{}
	for rows.Next() {
		var i ProjectTaskLink
		if err := rows.Scan(
			&i.ProjectID,
			&i.TaskID,
			&i.Role,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByStatus = `-- name: GetProjectsByStatus :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
`

type GetProjectsByStatusParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Status string      `json:"status"`
}

func (q *Queries) GetProjectsByStatus(ctx context.Context, arg GetProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUserID = `-- name: GetProjectsByUserID :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetProjectsByUserID(ctx context.Context, userID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMilestone = `-- name: UpdateMilestone :one
UPDATE milestones
SET
    name = $1,
    description = $2,
    due_date = $3,
    status = $4,
    progress = $5,
    display_order = $6,
    updated_at = NOW()
WHERE id = $7
RETURNING id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at
`

type UpdateMilestoneParams struct {
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	DueDate      pgtype.Timestamptz `json:"due_date"`
	Status       string             `json:"status"`
	Progress     pgtype.Numeric     `json:"progress"`
	DisplayOrder int32              `json:"display_order"`
	ID           pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateMilestone(ctx context.Context, arg UpdateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRow(ctx, updateMilestone,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Status,
		arg.Progress,
		arg.DisplayOrder,
		arg.ID,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET
    name = $1,
    description = $2,
    status = $3,
    start_date = $4,
    due_date = $5,
    health_overall = $6,
    health_on_track = $7,
    health_risk_factors = $8,
    health_last_updated = $9,
    metadata = $10,
    updated_at = NOW()
WHERE id = $11 AND user_id = $12
RETURNING id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at
`

type UpdateProjectParams struct {
	Name              string             `json:"name"`
	Description       pgtype.Text        `json:"description"`
	Status            string             `json:"status"`
	StartDate         pgtype.Timestamptz `json:"start_date"`
	DueDate           pgtype.Timestamptz `json:"due_date"`
	HealthOverall     pgtype.Numeric     `json:"health_overall"`
	HealthOnTrack     bool               `json:"health_on_track"`
	HealthRiskFactors []byte             `json:"health_risk_factors"`
	HealthLastUpdated pgtype.Timestamptz `json:"health_last_updated"`
	Metadata          []byte             `json:"metadata"`
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.StartDate,
		arg.DueDate,
		arg.HealthOverall,
		arg.HealthOnTrack,
		arg.HealthRiskFactors,
		arg.HealthLastUpdated,
		arg.Metadata,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
