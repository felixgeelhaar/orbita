// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: habits.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createHabit = `-- name: CreateHabit :exec
INSERT INTO habits (
    id, user_id, name, description, frequency, times_per_week,
    duration_minutes, preferred_time, streak, best_streak, total_done,
    archived, created_at, updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateHabitParams struct {
	ID              string         `json:"id"`
	UserID          string         `json:"user_id"`
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	Frequency       string         `json:"frequency"`
	TimesPerWeek    int64          `json:"times_per_week"`
	DurationMinutes int64          `json:"duration_minutes"`
	PreferredTime   sql.NullString `json:"preferred_time"`
	Streak          int64          `json:"streak"`
	BestStreak      int64          `json:"best_streak"`
	TotalDone       int64          `json:"total_done"`
	Archived        int64          `json:"archived"`
	CreatedAt       string         `json:"created_at"`
	UpdatedAt       string         `json:"updated_at"`
}

func (q *Queries) CreateHabit(ctx context.Context, arg CreateHabitParams) error {
	_, err := q.db.ExecContext(ctx, createHabit,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Frequency,
		arg.TimesPerWeek,
		arg.DurationMinutes,
		arg.PreferredTime,
		arg.Streak,
		arg.BestStreak,
		arg.TotalDone,
		arg.Archived,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHabitCompletion = `-- name: CreateHabitCompletion :exec
INSERT INTO habit_completions (id, habit_id, completed_at, notes, created_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateHabitCompletionParams struct {
	ID          string         `json:"id"`
	HabitID     string         `json:"habit_id"`
	CompletedAt string         `json:"completed_at"`
	Notes       sql.NullString `json:"notes"`
	CreatedAt   string         `json:"created_at"`
}

func (q *Queries) CreateHabitCompletion(ctx context.Context, arg CreateHabitCompletionParams) error {
	_, err := q.db.ExecContext(ctx, createHabitCompletion,
		arg.ID,
		arg.HabitID,
		arg.CompletedAt,
		arg.Notes,
		arg.CreatedAt,
	)
	return err
}

const deleteHabit = `-- name: DeleteHabit :exec
DELETE FROM habits WHERE id = ?
`

func (q *Queries) DeleteHabit(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteHabit, id)
	return err
}

const deleteHabitCompletionsByHabitID = `-- name: DeleteHabitCompletionsByHabitID :exec
DELETE FROM habit_completions WHERE habit_id = ?
`

func (q *Queries) DeleteHabitCompletionsByHabitID(ctx context.Context, habitID string) error {
	_, err := q.db.ExecContext(ctx, deleteHabitCompletionsByHabitID, habitID)
	return err
}

const getActiveHabitsByUserID = `-- name: GetActiveHabitsByUserID :many
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE user_id = ? AND archived = 0
ORDER BY created_at DESC
`

func (q *Queries) GetActiveHabitsByUserID(ctx context.Context, userID string) ([]Habit, error) {
	rows, err := q.db.QueryContext(ctx, getActiveHabitsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Habit{}
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Frequency,
			&i.TimesPerWeek,
			&i.DurationMinutes,
			&i.PreferredTime,
			&i.Streak,
			&i.BestStreak,
			&i.TotalDone,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitByID = `-- name: GetHabitByID :one
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE id = ?
`

func (q *Queries) GetHabitByID(ctx context.Context, id string) (Habit, error) {
	row := q.db.QueryRowContext(ctx, getHabitByID, id)
	var i Habit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Frequency,
		&i.TimesPerWeek,
		&i.DurationMinutes,
		&i.PreferredTime,
		&i.Streak,
		&i.BestStreak,
		&i.TotalDone,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHabitCompletionsByHabitID = `-- name: GetHabitCompletionsByHabitID :many
SELECT id, habit_id, completed_at, notes, created_at
FROM habit_completions
WHERE habit_id = ?
ORDER BY completed_at DESC
`

func (q *Queries) GetHabitCompletionsByHabitID(ctx context.Context, habitID string) ([]HabitCompletion, error) {
	rows, err := q.db.QueryContext(ctx, getHabitCompletionsByHabitID, habitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HabitCompletion{}
	for rows.Next() {
		var i HabitCompletion
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.CompletedAt,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitCompletionsByHabitIDSince = `-- name: GetHabitCompletionsByHabitIDSince :many
SELECT id, habit_id, completed_at, notes, created_at
FROM habit_completions
WHERE habit_id = ? AND completed_at >= ?
ORDER BY completed_at DESC
`

type GetHabitCompletionsByHabitIDSinceParams struct {
	HabitID     string `json:"habit_id"`
	CompletedAt string `json:"completed_at"`
}

func (q *Queries) GetHabitCompletionsByHabitIDSince(ctx context.Context, arg GetHabitCompletionsByHabitIDSinceParams) ([]HabitCompletion, error) {
	rows, err := q.db.QueryContext(ctx, getHabitCompletionsByHabitIDSince, arg.HabitID, arg.CompletedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HabitCompletion{}
	for rows.Next() {
		var i HabitCompletion
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.CompletedAt,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitsByUserID = `-- name: GetHabitsByUserID :many
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetHabitsByUserID(ctx context.Context, userID string) ([]Habit, error) {
	rows, err := q.db.QueryContext(ctx, getHabitsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Habit{}
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Frequency,
			&i.TimesPerWeek,
			&i.DurationMinutes,
			&i.PreferredTime,
			&i.Streak,
			&i.BestStreak,
			&i.TotalDone,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHabit = `-- name: UpdateHabit :exec
UPDATE habits
SET name = ?,
    description = ?,
    frequency = ?,
    times_per_week = ?,
    duration_minutes = ?,
    preferred_time = ?,
    streak = ?,
    best_streak = ?,
    total_done = ?,
    archived = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateHabitParams struct {
	Name            string         `json:"name"`
	Description     sql.NullString `json:"description"`
	Frequency       string         `json:"frequency"`
	TimesPerWeek    int64          `json:"times_per_week"`
	DurationMinutes int64          `json:"duration_minutes"`
	PreferredTime   sql.NullString `json:"preferred_time"`
	Streak          int64          `json:"streak"`
	BestStreak      int64          `json:"best_streak"`
	TotalDone       int64          `json:"total_done"`
	Archived        int64          `json:"archived"`
	UpdatedAt       string         `json:"updated_at"`
	ID              string         `json:"id"`
}

func (q *Queries) UpdateHabit(ctx context.Context, arg UpdateHabitParams) error {
	_, err := q.db.ExecContext(ctx, updateHabit,
		arg.Name,
		arg.Description,
		arg.Frequency,
		arg.TimesPerWeek,
		arg.DurationMinutes,
		arg.PreferredTime,
		arg.Streak,
		arg.BestStreak,
		arg.TotalDone,
		arg.Archived,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
