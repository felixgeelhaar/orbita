// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: habits.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createHabit = `-- name: CreateHabit :exec
INSERT INTO habits (
    id, user_id, name, description, frequency, times_per_week,
    duration_minutes, preferred_time, streak, best_streak, total_done,
    archived, created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
`

type CreateHabitParams struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Name            string             `json:"name"`
	Description     pgtype.Text        `json:"description"`
	Frequency       string             `json:"frequency"`
	TimesPerWeek    int32              `json:"times_per_week"`
	DurationMinutes int32              `json:"duration_minutes"`
	PreferredTime   pgtype.Text        `json:"preferred_time"`
	Streak          int32              `json:"streak"`
	BestStreak      int32              `json:"best_streak"`
	TotalDone       int32              `json:"total_done"`
	Archived        bool               `json:"archived"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateHabit(ctx context.Context, arg CreateHabitParams) error {
	_, err := q.db.Exec(ctx, createHabit,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Frequency,
		arg.TimesPerWeek,
		arg.DurationMinutes,
		arg.PreferredTime,
		arg.Streak,
		arg.BestStreak,
		arg.TotalDone,
		arg.Archived,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createHabitCompletion = `-- name: CreateHabitCompletion :exec
INSERT INTO habit_completions (id, habit_id, completed_at, notes, created_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateHabitCompletionParams struct {
	ID          pgtype.UUID        `json:"id"`
	HabitID     pgtype.UUID        `json:"habit_id"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
	Notes       pgtype.Text        `json:"notes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateHabitCompletion(ctx context.Context, arg CreateHabitCompletionParams) error {
	_, err := q.db.Exec(ctx, createHabitCompletion,
		arg.ID,
		arg.HabitID,
		arg.CompletedAt,
		arg.Notes,
		arg.CreatedAt,
	)
	return err
}

const deleteHabit = `-- name: DeleteHabit :exec
DELETE FROM habits WHERE id = $1
`

func (q *Queries) DeleteHabit(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteHabit, id)
	return err
}

const deleteHabitCompletionsByHabitID = `-- name: DeleteHabitCompletionsByHabitID :exec
DELETE FROM habit_completions WHERE habit_id = $1
`

func (q *Queries) DeleteHabitCompletionsByHabitID(ctx context.Context, habitID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteHabitCompletionsByHabitID, habitID)
	return err
}

const getActiveHabitsByUserID = `-- name: GetActiveHabitsByUserID :many
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE user_id = $1 AND archived = FALSE
ORDER BY created_at DESC
`

func (q *Queries) GetActiveHabitsByUserID(ctx context.Context, userID pgtype.UUID) ([]Habit, error) {
	rows, err := q.db.Query(ctx, getActiveHabitsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Habit{}
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Frequency,
			&i.TimesPerWeek,
			&i.DurationMinutes,
			&i.PreferredTime,
			&i.Streak,
			&i.BestStreak,
			&i.TotalDone,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitByID = `-- name: GetHabitByID :one
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE id = $1
`

func (q *Queries) GetHabitByID(ctx context.Context, id pgtype.UUID) (Habit, error) {
	row := q.db.QueryRow(ctx, getHabitByID, id)
	var i Habit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Frequency,
		&i.TimesPerWeek,
		&i.DurationMinutes,
		&i.PreferredTime,
		&i.Streak,
		&i.BestStreak,
		&i.TotalDone,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getHabitCompletionsByHabitID = `-- name: GetHabitCompletionsByHabitID :many
SELECT id, habit_id, completed_at, notes, created_at
FROM habit_completions
WHERE habit_id = $1
ORDER BY completed_at DESC
`

func (q *Queries) GetHabitCompletionsByHabitID(ctx context.Context, habitID pgtype.UUID) ([]HabitCompletion, error) {
	rows, err := q.db.Query(ctx, getHabitCompletionsByHabitID, habitID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HabitCompletion{}
	for rows.Next() {
		var i HabitCompletion
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.CompletedAt,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitCompletionsByHabitIDSince = `-- name: GetHabitCompletionsByHabitIDSince :many
SELECT id, habit_id, completed_at, notes, created_at
FROM habit_completions
WHERE habit_id = $1 AND completed_at >= $2
ORDER BY completed_at DESC
`

type GetHabitCompletionsByHabitIDSinceParams struct {
	HabitID     pgtype.UUID        `json:"habit_id"`
	CompletedAt pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetHabitCompletionsByHabitIDSince(ctx context.Context, arg GetHabitCompletionsByHabitIDSinceParams) ([]HabitCompletion, error) {
	rows, err := q.db.Query(ctx, getHabitCompletionsByHabitIDSince, arg.HabitID, arg.CompletedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []HabitCompletion{}
	for rows.Next() {
		var i HabitCompletion
		if err := rows.Scan(
			&i.ID,
			&i.HabitID,
			&i.CompletedAt,
			&i.Notes,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHabitsByUserID = `-- name: GetHabitsByUserID :many
SELECT id, user_id, name, description, frequency, times_per_week,
       duration_minutes, preferred_time, streak, best_streak, total_done,
       archived, created_at, updated_at
FROM habits
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetHabitsByUserID(ctx context.Context, userID pgtype.UUID) ([]Habit, error) {
	rows, err := q.db.Query(ctx, getHabitsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Habit{}
	for rows.Next() {
		var i Habit
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Frequency,
			&i.TimesPerWeek,
			&i.DurationMinutes,
			&i.PreferredTime,
			&i.Streak,
			&i.BestStreak,
			&i.TotalDone,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHabit = `-- name: UpdateHabit :exec
UPDATE habits
SET name = $2,
    description = $3,
    frequency = $4,
    times_per_week = $5,
    duration_minutes = $6,
    preferred_time = $7,
    streak = $8,
    best_streak = $9,
    total_done = $10,
    archived = $11,
    updated_at = $12
WHERE id = $1
`

type UpdateHabitParams struct {
	ID              pgtype.UUID        `json:"id"`
	Name            string             `json:"name"`
	Description     pgtype.Text        `json:"description"`
	Frequency       string             `json:"frequency"`
	TimesPerWeek    int32              `json:"times_per_week"`
	DurationMinutes int32              `json:"duration_minutes"`
	PreferredTime   pgtype.Text        `json:"preferred_time"`
	Streak          int32              `json:"streak"`
	BestStreak      int32              `json:"best_streak"`
	TotalDone       int32              `json:"total_done"`
	Archived        bool               `json:"archived"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateHabit(ctx context.Context, arg UpdateHabitParams) error {
	_, err := q.db.Exec(ctx, updateHabit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Frequency,
		arg.TimesPerWeek,
		arg.DurationMinutes,
		arg.PreferredTime,
		arg.Streak,
		arg.BestStreak,
		arg.TotalDone,
		arg.Archived,
		arg.UpdatedAt,
	)
	return err
}
