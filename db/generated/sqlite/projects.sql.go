// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package sqlite

import (
	"context"
	"database/sql"
)

const createMilestone = `-- name: CreateMilestone :one

INSERT INTO milestones (
    id, project_id, name, description, due_date,
    status, progress, display_order, created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at
`

type CreateMilestoneParams struct {
	ID           string         `json:"id"`
	ProjectID    string         `json:"project_id"`
	Name         string         `json:"name"`
	Description  sql.NullString `json:"description"`
	DueDate      string         `json:"due_date"`
	Status       string         `json:"status"`
	Progress     float64        `json:"progress"`
	DisplayOrder int64          `json:"display_order"`
	CreatedAt    string         `json:"created_at"`
	UpdatedAt    string         `json:"updated_at"`
}

// Milestones
func (q *Queries) CreateMilestone(ctx context.Context, arg CreateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRowContext(ctx, createMilestone,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Status,
		arg.Progress,
		arg.DisplayOrder,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMilestoneTaskLink = `-- name: CreateMilestoneTaskLink :exec

INSERT INTO milestone_task_links (milestone_id, task_id, role, display_order, created_at)
VALUES (?, ?, ?, ?, datetime('now'))
`

type CreateMilestoneTaskLinkParams struct {
	MilestoneID  string `json:"milestone_id"`
	TaskID       string `json:"task_id"`
	Role         string `json:"role"`
	DisplayOrder int64  `json:"display_order"`
}

// Milestone Task Links
func (q *Queries) CreateMilestoneTaskLink(ctx context.Context, arg CreateMilestoneTaskLinkParams) error {
	_, err := q.db.ExecContext(ctx, createMilestoneTaskLink,
		arg.MilestoneID,
		arg.TaskID,
		arg.Role,
		arg.DisplayOrder,
	)
	return err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    id, user_id, name, description, status,
    start_date, due_date, health_overall, health_on_track,
    health_risk_factors, health_last_updated, metadata,
    created_at, updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at
`

type CreateProjectParams struct {
	ID                string         `json:"id"`
	UserID            string         `json:"user_id"`
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Status            string         `json:"status"`
	StartDate         sql.NullString `json:"start_date"`
	DueDate           sql.NullString `json:"due_date"`
	HealthOverall     float64        `json:"health_overall"`
	HealthOnTrack     int64          `json:"health_on_track"`
	HealthRiskFactors string         `json:"health_risk_factors"`
	HealthLastUpdated string         `json:"health_last_updated"`
	Metadata          string         `json:"metadata"`
	CreatedAt         string         `json:"created_at"`
	UpdatedAt         string         `json:"updated_at"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.StartDate,
		arg.DueDate,
		arg.HealthOverall,
		arg.HealthOnTrack,
		arg.HealthRiskFactors,
		arg.HealthLastUpdated,
		arg.Metadata,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProjectTaskLink = `-- name: CreateProjectTaskLink :exec

INSERT INTO project_task_links (project_id, task_id, role, display_order, created_at)
VALUES (?, ?, ?, ?, datetime('now'))
`

type CreateProjectTaskLinkParams struct {
	ProjectID    string `json:"project_id"`
	TaskID       string `json:"task_id"`
	Role         string `json:"role"`
	DisplayOrder int64  `json:"display_order"`
}

// Project Task Links
func (q *Queries) CreateProjectTaskLink(ctx context.Context, arg CreateProjectTaskLinkParams) error {
	_, err := q.db.ExecContext(ctx, createProjectTaskLink,
		arg.ProjectID,
		arg.TaskID,
		arg.Role,
		arg.DisplayOrder,
	)
	return err
}

const deleteAllMilestoneTaskLinks = `-- name: DeleteAllMilestoneTaskLinks :exec
DELETE FROM milestone_task_links WHERE milestone_id = ?
`

func (q *Queries) DeleteAllMilestoneTaskLinks(ctx context.Context, milestoneID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllMilestoneTaskLinks, milestoneID)
	return err
}

const deleteAllProjectTaskLinks = `-- name: DeleteAllProjectTaskLinks :exec
DELETE FROM project_task_links WHERE project_id = ?
`

func (q *Queries) DeleteAllProjectTaskLinks(ctx context.Context, projectID string) error {
	_, err := q.db.ExecContext(ctx, deleteAllProjectTaskLinks, projectID)
	return err
}

const deleteMilestone = `-- name: DeleteMilestone :exec
DELETE FROM milestones WHERE id = ?
`

func (q *Queries) DeleteMilestone(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteMilestone, id)
	return err
}

const deleteMilestoneTaskLink = `-- name: DeleteMilestoneTaskLink :exec
DELETE FROM milestone_task_links WHERE milestone_id = ? AND task_id = ?
`

type DeleteMilestoneTaskLinkParams struct {
	MilestoneID string `json:"milestone_id"`
	TaskID      string `json:"task_id"`
}

func (q *Queries) DeleteMilestoneTaskLink(ctx context.Context, arg DeleteMilestoneTaskLinkParams) error {
	_, err := q.db.ExecContext(ctx, deleteMilestoneTaskLink, arg.MilestoneID, arg.TaskID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = ? AND user_id = ?
`

type DeleteProjectParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.ExecContext(ctx, deleteProject, arg.ID, arg.UserID)
	return err
}

const deleteProjectTaskLink = `-- name: DeleteProjectTaskLink :exec
DELETE FROM project_task_links WHERE project_id = ? AND task_id = ?
`

type DeleteProjectTaskLinkParams struct {
	ProjectID string `json:"project_id"`
	TaskID    string `json:"task_id"`
}

func (q *Queries) DeleteProjectTaskLink(ctx context.Context, arg DeleteProjectTaskLinkParams) error {
	_, err := q.db.ExecContext(ctx, deleteProjectTaskLink, arg.ProjectID, arg.TaskID)
	return err
}

const getActiveProjects = `-- name: GetActiveProjects :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = ? AND status NOT IN ('completed', 'archived')
ORDER BY
    CASE WHEN due_date IS NULL THEN 1 ELSE 0 END,
    due_date,
    created_at DESC
`

func (q *Queries) GetActiveProjects(ctx context.Context, userID string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMilestoneByID = `-- name: GetMilestoneByID :one
SELECT id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at FROM milestones WHERE id = ?
`

func (q *Queries) GetMilestoneByID(ctx context.Context, id string) (Milestone, error) {
	row := q.db.QueryRowContext(ctx, getMilestoneByID, id)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMilestoneTaskLinks = `-- name: GetMilestoneTaskLinks :many
SELECT milestone_id, task_id, role, display_order, created_at FROM milestone_task_links
WHERE milestone_id = ?
ORDER BY display_order
`

func (q *Queries) GetMilestoneTaskLinks(ctx context.Context, milestoneID string) ([]MilestoneTaskLink, error) {
	rows, err := q.db.QueryContext(ctx, getMilestoneTaskLinks, milestoneID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MilestoneTaskLink{}
	for rows.Next() {
		var i MilestoneTaskLink
		if err := rows.Scan(
			&i.MilestoneID,
			&i.TaskID,
			&i.Role,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMilestonesByProjectID = `-- name: GetMilestonesByProjectID :many
SELECT id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at FROM milestones
WHERE project_id = ?
ORDER BY display_order, due_date
`

func (q *Queries) GetMilestonesByProjectID(ctx context.Context, projectID string) ([]Milestone, error) {
	rows, err := q.db.QueryContext(ctx, getMilestonesByProjectID, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Milestone{}
	for rows.Next() {
		var i Milestone
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.DueDate,
			&i.Status,
			&i.Progress,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects WHERE id = ? AND user_id = ?
`

type GetProjectByIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetProjectByID(ctx context.Context, arg GetProjectByIDParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, arg.ID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectTaskLinks = `-- name: GetProjectTaskLinks :many
SELECT project_id, task_id, role, display_order, created_at FROM project_task_links
WHERE project_id = ?
ORDER BY display_order
`

func (q *Queries) GetProjectTaskLinks(ctx context.Context, projectID string) ([]ProjectTaskLink, error) {
	rows, err := q.db.QueryContext(ctx, getProjectTaskLinks, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectTaskLink{}
	for rows.Next() {
		var i ProjectTaskLink
		if err := rows.Scan(
			&i.ProjectID,
			&i.TaskID,
			&i.Role,
			&i.DisplayOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByStatus = `-- name: GetProjectsByStatus :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = ? AND status = ?
ORDER BY created_at DESC
`

type GetProjectsByStatusParams struct {
	UserID string `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) GetProjectsByStatus(ctx context.Context, arg GetProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsByStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUserID = `-- name: GetProjectsByUserID :many
SELECT id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at FROM projects
WHERE user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetProjectsByUserID(ctx context.Context, userID string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, getProjectsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Status,
			&i.StartDate,
			&i.DueDate,
			&i.HealthOverall,
			&i.HealthOnTrack,
			&i.HealthRiskFactors,
			&i.HealthLastUpdated,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMilestone = `-- name: UpdateMilestone :one
UPDATE milestones
SET
    name = ?,
    description = ?,
    due_date = ?,
    status = ?,
    progress = ?,
    display_order = ?,
    updated_at = datetime('now')
WHERE id = ?
RETURNING id, project_id, name, description, due_date, status, progress, display_order, created_at, updated_at
`

type UpdateMilestoneParams struct {
	Name         string         `json:"name"`
	Description  sql.NullString `json:"description"`
	DueDate      string         `json:"due_date"`
	Status       string         `json:"status"`
	Progress     float64        `json:"progress"`
	DisplayOrder int64          `json:"display_order"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateMilestone(ctx context.Context, arg UpdateMilestoneParams) (Milestone, error) {
	row := q.db.QueryRowContext(ctx, updateMilestone,
		arg.Name,
		arg.Description,
		arg.DueDate,
		arg.Status,
		arg.Progress,
		arg.DisplayOrder,
		arg.ID,
	)
	var i Milestone
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.DueDate,
		&i.Status,
		&i.Progress,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET
    name = ?,
    description = ?,
    status = ?,
    start_date = ?,
    due_date = ?,
    health_overall = ?,
    health_on_track = ?,
    health_risk_factors = ?,
    health_last_updated = ?,
    metadata = ?,
    updated_at = datetime('now')
WHERE id = ? AND user_id = ?
RETURNING id, user_id, name, description, status, start_date, due_date, health_overall, health_on_track, health_risk_factors, health_last_updated, metadata, created_at, updated_at
`

type UpdateProjectParams struct {
	Name              string         `json:"name"`
	Description       sql.NullString `json:"description"`
	Status            string         `json:"status"`
	StartDate         sql.NullString `json:"start_date"`
	DueDate           sql.NullString `json:"due_date"`
	HealthOverall     float64        `json:"health_overall"`
	HealthOnTrack     int64          `json:"health_on_track"`
	HealthRiskFactors string         `json:"health_risk_factors"`
	HealthLastUpdated string         `json:"health_last_updated"`
	Metadata          string         `json:"metadata"`
	ID                string         `json:"id"`
	UserID            string         `json:"user_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Name,
		arg.Description,
		arg.Status,
		arg.StartDate,
		arg.DueDate,
		arg.HealthOverall,
		arg.HealthOnTrack,
		arg.HealthRiskFactors,
		arg.HealthLastUpdated,
		arg.Metadata,
		arg.ID,
		arg.UserID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Status,
		&i.StartDate,
		&i.DueDate,
		&i.HealthOverall,
		&i.HealthOnTrack,
		&i.HealthRiskFactors,
		&i.HealthLastUpdated,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
