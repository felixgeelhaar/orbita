// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: automations.sql

package sqlite

import (
	"context"
	"database/sql"
)

const cancelAutomationPendingActionsByRuleID = `-- name: CancelAutomationPendingActionsByRuleID :exec
UPDATE automation_pending_actions
SET status = 'cancelled'
WHERE rule_id = ? AND status = 'pending'
`

func (q *Queries) CancelAutomationPendingActionsByRuleID(ctx context.Context, ruleID string) error {
	_, err := q.db.ExecContext(ctx, cancelAutomationPendingActionsByRuleID, ruleID)
	return err
}

const countAutomationRuleExecutionsSince = `-- name: CountAutomationRuleExecutionsSince :one
SELECT COUNT(*)
FROM automation_rule_executions
WHERE rule_id = ? AND started_at >= ?
`

type CountAutomationRuleExecutionsSinceParams struct {
	RuleID    string `json:"rule_id"`
	StartedAt string `json:"started_at"`
}

func (q *Queries) CountAutomationRuleExecutionsSince(ctx context.Context, arg CountAutomationRuleExecutionsSinceParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAutomationRuleExecutionsSince, arg.RuleID, arg.StartedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countAutomationRulesByUserID = `-- name: CountAutomationRulesByUserID :one
SELECT COUNT(*) FROM automation_rules WHERE user_id = ?
`

func (q *Queries) CountAutomationRulesByUserID(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAutomationRulesByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAutomationPendingAction = `-- name: CreateAutomationPendingAction :exec
INSERT INTO automation_pending_actions (
    id, execution_id, rule_id, user_id, action_type, action_params,
    scheduled_for, status, executed_at, result, error_message,
    retry_count, max_retries, created_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateAutomationPendingActionParams struct {
	ID           string         `json:"id"`
	ExecutionID  string         `json:"execution_id"`
	RuleID       string         `json:"rule_id"`
	UserID       string         `json:"user_id"`
	ActionType   string         `json:"action_type"`
	ActionParams string         `json:"action_params"`
	ScheduledFor string         `json:"scheduled_for"`
	Status       string         `json:"status"`
	ExecutedAt   sql.NullString `json:"executed_at"`
	Result       sql.NullString `json:"result"`
	ErrorMessage sql.NullString `json:"error_message"`
	RetryCount   int64          `json:"retry_count"`
	MaxRetries   int64          `json:"max_retries"`
	CreatedAt    string         `json:"created_at"`
}

func (q *Queries) CreateAutomationPendingAction(ctx context.Context, arg CreateAutomationPendingActionParams) error {
	_, err := q.db.ExecContext(ctx, createAutomationPendingAction,
		arg.ID,
		arg.ExecutionID,
		arg.RuleID,
		arg.UserID,
		arg.ActionType,
		arg.ActionParams,
		arg.ScheduledFor,
		arg.Status,
		arg.ExecutedAt,
		arg.Result,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.MaxRetries,
		arg.CreatedAt,
	)
	return err
}

const createAutomationRule = `-- name: CreateAutomationRule :exec
INSERT INTO automation_rules (
    id, user_id, name, description, enabled, priority,
    trigger_type, trigger_config, conditions, condition_operator,
    actions, cooldown_seconds, max_executions_per_hour, tags,
    created_at, updated_at, last_triggered_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateAutomationRuleParams struct {
	ID                   string         `json:"id"`
	UserID               string         `json:"user_id"`
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	Enabled              int64          `json:"enabled"`
	Priority             int64          `json:"priority"`
	TriggerType          string         `json:"trigger_type"`
	TriggerConfig        string         `json:"trigger_config"`
	Conditions           string         `json:"conditions"`
	ConditionOperator    string         `json:"condition_operator"`
	Actions              string         `json:"actions"`
	CooldownSeconds      int64          `json:"cooldown_seconds"`
	MaxExecutionsPerHour sql.NullInt64  `json:"max_executions_per_hour"`
	Tags                 sql.NullString `json:"tags"`
	CreatedAt            string         `json:"created_at"`
	UpdatedAt            string         `json:"updated_at"`
	LastTriggeredAt      sql.NullString `json:"last_triggered_at"`
}

func (q *Queries) CreateAutomationRule(ctx context.Context, arg CreateAutomationRuleParams) error {
	_, err := q.db.ExecContext(ctx, createAutomationRule,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.Priority,
		arg.TriggerType,
		arg.TriggerConfig,
		arg.Conditions,
		arg.ConditionOperator,
		arg.Actions,
		arg.CooldownSeconds,
		arg.MaxExecutionsPerHour,
		arg.Tags,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.LastTriggeredAt,
	)
	return err
}

const createAutomationRuleExecution = `-- name: CreateAutomationRuleExecution :exec
INSERT INTO automation_rule_executions (
    id, rule_id, user_id, trigger_event_type, trigger_event_payload,
    status, actions_executed, error_message, error_details,
    started_at, completed_at, duration_ms, skip_reason
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateAutomationRuleExecutionParams struct {
	ID                  string         `json:"id"`
	RuleID              string         `json:"rule_id"`
	UserID              string         `json:"user_id"`
	TriggerEventType    sql.NullString `json:"trigger_event_type"`
	TriggerEventPayload sql.NullString `json:"trigger_event_payload"`
	Status              string         `json:"status"`
	ActionsExecuted     string         `json:"actions_executed"`
	ErrorMessage        sql.NullString `json:"error_message"`
	ErrorDetails        sql.NullString `json:"error_details"`
	StartedAt           string         `json:"started_at"`
	CompletedAt         sql.NullString `json:"completed_at"`
	DurationMs          sql.NullInt64  `json:"duration_ms"`
	SkipReason          sql.NullString `json:"skip_reason"`
}

func (q *Queries) CreateAutomationRuleExecution(ctx context.Context, arg CreateAutomationRuleExecutionParams) error {
	_, err := q.db.ExecContext(ctx, createAutomationRuleExecution,
		arg.ID,
		arg.RuleID,
		arg.UserID,
		arg.TriggerEventType,
		arg.TriggerEventPayload,
		arg.Status,
		arg.ActionsExecuted,
		arg.ErrorMessage,
		arg.ErrorDetails,
		arg.StartedAt,
		arg.CompletedAt,
		arg.DurationMs,
		arg.SkipReason,
	)
	return err
}

const deleteAutomationRule = `-- name: DeleteAutomationRule :exec
DELETE FROM automation_rules WHERE id = ?
`

func (q *Queries) DeleteAutomationRule(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteAutomationRule, id)
	return err
}

const deleteAutomationRuleExecutionsOlderThan = `-- name: DeleteAutomationRuleExecutionsOlderThan :exec
DELETE FROM automation_rule_executions
WHERE completed_at < ?
`

func (q *Queries) DeleteAutomationRuleExecutionsOlderThan(ctx context.Context, completedAt sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteAutomationRuleExecutionsOlderThan, completedAt)
	return err
}

const deleteExecutedAutomationPendingActions = `-- name: DeleteExecutedAutomationPendingActions :exec
DELETE FROM automation_pending_actions
WHERE status IN ('executed', 'cancelled', 'failed')
  AND executed_at < ?
`

func (q *Queries) DeleteExecutedAutomationPendingActions(ctx context.Context, executedAt sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteExecutedAutomationPendingActions, executedAt)
	return err
}

const getAutomationPendingActionByID = `-- name: GetAutomationPendingActionByID :one

SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE id = ?
`

// Automation Pending Actions
func (q *Queries) GetAutomationPendingActionByID(ctx context.Context, id string) (AutomationPendingAction, error) {
	row := q.db.QueryRowContext(ctx, getAutomationPendingActionByID, id)
	var i AutomationPendingAction
	err := row.Scan(
		&i.ID,
		&i.ExecutionID,
		&i.RuleID,
		&i.UserID,
		&i.ActionType,
		&i.ActionParams,
		&i.ScheduledFor,
		&i.Status,
		&i.ExecutedAt,
		&i.Result,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
		&i.CreatedAt,
	)
	return i, err
}

const getAutomationPendingActionsByExecutionID = `-- name: GetAutomationPendingActionsByExecutionID :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE execution_id = ?
ORDER BY scheduled_for ASC
`

func (q *Queries) GetAutomationPendingActionsByExecutionID(ctx context.Context, executionID string) ([]AutomationPendingAction, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationPendingActionsByExecutionID, executionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationPendingActionsByRuleID = `-- name: GetAutomationPendingActionsByRuleID :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE rule_id = ?
ORDER BY scheduled_for DESC
`

func (q *Queries) GetAutomationPendingActionsByRuleID(ctx context.Context, ruleID string) ([]AutomationPendingAction, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationPendingActionsByRuleID, ruleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationRuleByID = `-- name: GetAutomationRuleByID :one

SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE id = ?
`

// Automation Rules
func (q *Queries) GetAutomationRuleByID(ctx context.Context, id string) (AutomationRule, error) {
	row := q.db.QueryRowContext(ctx, getAutomationRuleByID, id)
	var i AutomationRule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.Enabled,
		&i.Priority,
		&i.TriggerType,
		&i.TriggerConfig,
		&i.Conditions,
		&i.ConditionOperator,
		&i.Actions,
		&i.CooldownSeconds,
		&i.MaxExecutionsPerHour,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastTriggeredAt,
	)
	return i, err
}

const getAutomationRuleExecutionByID = `-- name: GetAutomationRuleExecutionByID :one

SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE id = ?
`

// Automation Rule Executions
func (q *Queries) GetAutomationRuleExecutionByID(ctx context.Context, id string) (AutomationRuleExecution, error) {
	row := q.db.QueryRowContext(ctx, getAutomationRuleExecutionByID, id)
	var i AutomationRuleExecution
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.UserID,
		&i.TriggerEventType,
		&i.TriggerEventPayload,
		&i.Status,
		&i.ActionsExecuted,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.SkipReason,
	)
	return i, err
}

const getAutomationRuleExecutionsByRuleID = `-- name: GetAutomationRuleExecutionsByRuleID :many
SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE rule_id = ?
ORDER BY started_at DESC
LIMIT ?
`

type GetAutomationRuleExecutionsByRuleIDParams struct {
	RuleID string `json:"rule_id"`
	Limit  int64  `json:"limit"`
}

func (q *Queries) GetAutomationRuleExecutionsByRuleID(ctx context.Context, arg GetAutomationRuleExecutionsByRuleIDParams) ([]AutomationRuleExecution, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationRuleExecutionsByRuleID, arg.RuleID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRuleExecution{}
	for rows.Next() {
		var i AutomationRuleExecution
		if err := rows.Scan(
			&i.ID,
			&i.RuleID,
			&i.UserID,
			&i.TriggerEventType,
			&i.TriggerEventPayload,
			&i.Status,
			&i.ActionsExecuted,
			&i.ErrorMessage,
			&i.ErrorDetails,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.SkipReason,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAutomationRulesByUserID = `-- name: GetAutomationRulesByUserID :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = ?
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) GetAutomationRulesByUserID(ctx context.Context, userID string) ([]AutomationRule, error) {
	rows, err := q.db.QueryContext(ctx, getAutomationRulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDueAutomationPendingActions = `-- name: GetDueAutomationPendingActions :many
SELECT id, execution_id, rule_id, user_id, action_type, action_params,
       scheduled_for, status, executed_at, result, error_message,
       retry_count, max_retries, created_at
FROM automation_pending_actions
WHERE status = 'pending' AND scheduled_for <= datetime('now')
ORDER BY scheduled_for ASC
LIMIT ?
`

func (q *Queries) GetDueAutomationPendingActions(ctx context.Context, limit int64) ([]AutomationPendingAction, error) {
	rows, err := q.db.QueryContext(ctx, getDueAutomationPendingActions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationPendingAction{}
	for rows.Next() {
		var i AutomationPendingAction
		if err := rows.Scan(
			&i.ID,
			&i.ExecutionID,
			&i.RuleID,
			&i.UserID,
			&i.ActionType,
			&i.ActionParams,
			&i.ScheduledFor,
			&i.Status,
			&i.ExecutedAt,
			&i.Result,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledAutomationRulesByTriggerType = `-- name: GetEnabledAutomationRulesByTriggerType :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = ? AND enabled = 1 AND trigger_type = ?
ORDER BY priority DESC, created_at DESC
`

type GetEnabledAutomationRulesByTriggerTypeParams struct {
	UserID      string `json:"user_id"`
	TriggerType string `json:"trigger_type"`
}

func (q *Queries) GetEnabledAutomationRulesByTriggerType(ctx context.Context, arg GetEnabledAutomationRulesByTriggerTypeParams) ([]AutomationRule, error) {
	rows, err := q.db.QueryContext(ctx, getEnabledAutomationRulesByTriggerType, arg.UserID, arg.TriggerType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnabledAutomationRulesByUserID = `-- name: GetEnabledAutomationRulesByUserID :many
SELECT id, user_id, name, description, enabled, priority,
       trigger_type, trigger_config, conditions, condition_operator,
       actions, cooldown_seconds, max_executions_per_hour, tags,
       created_at, updated_at, last_triggered_at
FROM automation_rules
WHERE user_id = ? AND enabled = 1
ORDER BY priority DESC, created_at DESC
`

func (q *Queries) GetEnabledAutomationRulesByUserID(ctx context.Context, userID string) ([]AutomationRule, error) {
	rows, err := q.db.QueryContext(ctx, getEnabledAutomationRulesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AutomationRule{}
	for rows.Next() {
		var i AutomationRule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.Enabled,
			&i.Priority,
			&i.TriggerType,
			&i.TriggerConfig,
			&i.Conditions,
			&i.ConditionOperator,
			&i.Actions,
			&i.CooldownSeconds,
			&i.MaxExecutionsPerHour,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAutomationRuleExecution = `-- name: GetLatestAutomationRuleExecution :one
SELECT id, rule_id, user_id, trigger_event_type, trigger_event_payload,
       status, actions_executed, error_message, error_details,
       started_at, completed_at, duration_ms, skip_reason
FROM automation_rule_executions
WHERE rule_id = ?
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetLatestAutomationRuleExecution(ctx context.Context, ruleID string) (AutomationRuleExecution, error) {
	row := q.db.QueryRowContext(ctx, getLatestAutomationRuleExecution, ruleID)
	var i AutomationRuleExecution
	err := row.Scan(
		&i.ID,
		&i.RuleID,
		&i.UserID,
		&i.TriggerEventType,
		&i.TriggerEventPayload,
		&i.Status,
		&i.ActionsExecuted,
		&i.ErrorMessage,
		&i.ErrorDetails,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.SkipReason,
	)
	return i, err
}

const updateAutomationPendingAction = `-- name: UpdateAutomationPendingAction :exec
UPDATE automation_pending_actions
SET status = ?,
    executed_at = ?,
    result = ?,
    error_message = ?,
    retry_count = ?
WHERE id = ?
`

type UpdateAutomationPendingActionParams struct {
	Status       string         `json:"status"`
	ExecutedAt   sql.NullString `json:"executed_at"`
	Result       sql.NullString `json:"result"`
	ErrorMessage sql.NullString `json:"error_message"`
	RetryCount   int64          `json:"retry_count"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateAutomationPendingAction(ctx context.Context, arg UpdateAutomationPendingActionParams) error {
	_, err := q.db.ExecContext(ctx, updateAutomationPendingAction,
		arg.Status,
		arg.ExecutedAt,
		arg.Result,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.ID,
	)
	return err
}

const updateAutomationRule = `-- name: UpdateAutomationRule :exec
UPDATE automation_rules
SET name = ?,
    description = ?,
    enabled = ?,
    priority = ?,
    trigger_type = ?,
    trigger_config = ?,
    conditions = ?,
    condition_operator = ?,
    actions = ?,
    cooldown_seconds = ?,
    max_executions_per_hour = ?,
    tags = ?,
    updated_at = ?,
    last_triggered_at = ?
WHERE id = ?
`

type UpdateAutomationRuleParams struct {
	Name                 string         `json:"name"`
	Description          sql.NullString `json:"description"`
	Enabled              int64          `json:"enabled"`
	Priority             int64          `json:"priority"`
	TriggerType          string         `json:"trigger_type"`
	TriggerConfig        string         `json:"trigger_config"`
	Conditions           string         `json:"conditions"`
	ConditionOperator    string         `json:"condition_operator"`
	Actions              string         `json:"actions"`
	CooldownSeconds      int64          `json:"cooldown_seconds"`
	MaxExecutionsPerHour sql.NullInt64  `json:"max_executions_per_hour"`
	Tags                 sql.NullString `json:"tags"`
	UpdatedAt            string         `json:"updated_at"`
	LastTriggeredAt      sql.NullString `json:"last_triggered_at"`
	ID                   string         `json:"id"`
}

func (q *Queries) UpdateAutomationRule(ctx context.Context, arg UpdateAutomationRuleParams) error {
	_, err := q.db.ExecContext(ctx, updateAutomationRule,
		arg.Name,
		arg.Description,
		arg.Enabled,
		arg.Priority,
		arg.TriggerType,
		arg.TriggerConfig,
		arg.Conditions,
		arg.ConditionOperator,
		arg.Actions,
		arg.CooldownSeconds,
		arg.MaxExecutionsPerHour,
		arg.Tags,
		arg.UpdatedAt,
		arg.LastTriggeredAt,
		arg.ID,
	)
	return err
}

const updateAutomationRuleExecution = `-- name: UpdateAutomationRuleExecution :exec
UPDATE automation_rule_executions
SET status = ?,
    actions_executed = ?,
    error_message = ?,
    error_details = ?,
    completed_at = ?,
    duration_ms = ?,
    skip_reason = ?
WHERE id = ?
`

type UpdateAutomationRuleExecutionParams struct {
	Status          string         `json:"status"`
	ActionsExecuted string         `json:"actions_executed"`
	ErrorMessage    sql.NullString `json:"error_message"`
	ErrorDetails    sql.NullString `json:"error_details"`
	CompletedAt     sql.NullString `json:"completed_at"`
	DurationMs      sql.NullInt64  `json:"duration_ms"`
	SkipReason      sql.NullString `json:"skip_reason"`
	ID              string         `json:"id"`
}

func (q *Queries) UpdateAutomationRuleExecution(ctx context.Context, arg UpdateAutomationRuleExecutionParams) error {
	_, err := q.db.ExecContext(ctx, updateAutomationRuleExecution,
		arg.Status,
		arg.ActionsExecuted,
		arg.ErrorMessage,
		arg.ErrorDetails,
		arg.CompletedAt,
		arg.DurationMs,
		arg.SkipReason,
		arg.ID,
	)
	return err
}
